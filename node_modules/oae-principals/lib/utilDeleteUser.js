/*!
 * Copyright 2017 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');

var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var Cassandra = require('oae-util/lib/cassandra');
var Context = require('oae-context').Context;
var log = require('oae-logger').logger('oae-principals');

// API
var ConfigAPI = require('oae-config');
var TenantsAPI = require('oae-tenants');
var ContentAPI = require('oae-content');
var AuthzAPI = require('oae-authz');
var FolderAPI = require('oae-folders');
var DiscussionAPI = require('oae-discussions/lib/api.discussions');
var GroupAPI = require('./api.group');

// DAO
var FollowingDAO = require('oae-following/lib/internal/dao');
var DiscussionsDAO = require('oae-discussions/lib/internal/dao');

// PRINCIPALS
var PrincipalsConfig = ConfigAPI.config('oae-principals');
var PrincipalsConstants = require('./constants').PrincipalsConstants;
var PrincipalsDAO = require('./internal/dao');
var PrincipalsEmitter = require('./internal/emitter');


/**
 * Get or create user archive
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Object}     user            User
 * @param  {String}     defaultValue    The default value returned in case of no result
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var getOrCreateArchiveUser =  module.exports.getOrCreateArchiveUser = function(ctx, user, callback) {

    // Get email
    emailDomains = user.tenant.emailDomains;

    // Get tenant
    tenant = TenantsAPI.getTenantsForEmailDomains(emailDomains)
    
    // Get and/or create archiveUser
    PrincipalsDAO.getOrCreateArchiveUser(ctx, tenant[emailDomains], function(err, userArchive) {
        if(err){
            return callback(err);
        }
        return callback(null, userArchive);
    });
};

/**
 * Get a configuration
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     configkey       The config key to get the value of key
 * @param  {String}     defaultValue    The default value returned in case of no result
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var getConfig = module.exports.getConfig = function(ctx, configkey, defaultValue, callback) {
    if (_.isEmpty(ctx)) {
        return callback(null, []);
    }

    Cassandra.runQuery('SELECT "value" FROM "Config" WHERE "tenantAlias" = ? AND "configKey" = ?', [ctx.tenant().alias, configkey], function(err, result) {
        if (err) {
            return callback(err);
        }

        if (_.isEmpty(result)) {
            return callback(null, defaultValue);
            
        } else {
            res = _.chain(result).map(Cassandra.rowToHash)._wrapped[0];
            return callback(null, res.value);
        }
    });
};

/**
 * Delete rights on a user && update roles on editors && update roles on user archive
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            User that will be deleted
 * @param  {String}     archiveUser     User Archive
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var transferDataToArchive = module.exports.transferDataToArchive = function (ctx, user, archiveUser,callback) {
    callback = callback || function() {};

    // Transfer or update rights in contents
    _transferRightContent(ctx, user, archiveUser, function(err) {
        if (err) {
            return callback(err);
        }

        // Transfer or update rights in folders
        _transferRightFolder(ctx, user, archiveUser, function(err) {
            if (err) {
                return callback(err);
            } 

            // Transfer or update rights in discussions
            _transferRightDiscussions(ctx, user, archiveUser, function(err) {
                if (err) {
                    return callback(err);
                }  

                // Transfer or update rights in groups
                /*_transferRightGroup(ctx, user, archiveUser, function(err) {
                    if (err) {
                        return callback(err);
                    }*/

                    // Delete rights in followers
                    _deleteFollowers(user, function(err) {
                        if (err) {
                            return callback(err);
                        }
                    });
                //});
            });
        });
    });            
};

/**
 * Delete rights on contents && update roles on editors && update roles on user archive
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            User that will be deleted
 * @param  {String}     archiveUser     User Archive
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var _transferRightContent = function(ctx, user, archiveUser, callback) {

    // Get all documents 
    ContentAPI.getContentLibraryItems(ctx, user.id, null, null, function(err, contents) {
        if(err) {
            return callback(err);
        }
        if(_.isEmpty(contents)) {
            return callback();
        }
        var contentIds = [];
        contents.forEach(function(element, id, arr) {

            // Get his role
            AuthzAPI.hasRole(user.id, element.id, AuthzConstants.role.MANAGER, function(err, hasRole) {
                if(err) {
                    return callback(err);
                }

                // Delete all his right and remove from library
                ContentAPI.removeContentFromLibrary(ctx, user.id, element.id, true, function(err) {
                    if(err) {
                        return callback(err);
                    }

                    // If he's not a manager, do nothing, if else...
                    if(hasRole) {

                        // Search if other user have right on this document
                        ContentAPI.getContentMembersLibrary(ctx, element.id, null, null, function(err, memberList) {
                            if(err) {
                                return callback(err);
                            }

                            // If member list is empty - return
                            if(_.isEmpty(memberList)) { 
                                _addToArchive(archiveUser.idArchive, user.id, element.id, function(err){
                                    if(err) {
                                        return callback(err);
                                    }
                                }); 
                            } 

                            // If there is member, analyze them....
                            var editors = [];
                            var hasManager = false;

                            // If there is some members, look at his rights
                            memberList.forEach(function(person, idx, array) {

                                // If we have already find a manager, do nothing
                                if(hasManager) { return; }

                                // If he's manager, return and set hasmanager to true
                                if(person.role === AuthzConstants.role.MANAGER ) { 
                                    hasManager = true;
                                    return;
                                }  

                                // If he's editor, add to editors list
                                if(person.role === AuthzConstants.role.EDITOR) {
                                    editors.push(person.profile.id)
                                } 

                                // If it's the last iteration and we don't find any manager, promote all editor -> manager
                                if (idx === array.length - 1) { 
                                    if(_.isEmpty(editors) && !hasManager) {
                                        _addToArchive(archiveUser.idArchive, user.id, element.id, function(err){
                                            if(err) {
                                                return callback(err);
                                            }
                                        });  
                                    } else if (!hasManager) {
                                        var update = {};
                                        editors.forEach(function(editor, idEditor, arrayEditor) {
                                            
                                            update[editor] = AuthzConstants.role.MANAGER;

                                            // When no more editor, do update
                                            if (idEditor === arrayEditor.length - 1) { 
                                                AuthzAPI.updateRoles(element.id, update, function(err, usersToInvalidate){
                                                    if(err) {
                                                        return callback(err);
                                                    }
                                                });
                                            };
                                        });
                                    }
                                }
                            });
                        });
                    }
               });
            });

            // When no more content, return callback
            if (id === arr.length - 1) { 
                return callback(null);                    
            }
        });   
    });
};

/**
 * Delete rights on folders && update roles on editors && update roles on user archive
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            The user to delete
 * @param  {String}     archiveUser     User Archive
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var _transferRightFolder = function(ctx, user, archiveUser, callback) {

    // Get all documents 
    FolderAPI.getFoldersLibrary(ctx, user.id, null, null, function(err, folders) {
        if(err) {
            return callback(err);
        }
        if(_.isEmpty(folders)) {
            return callback();
        }
        var contentIds = [];
        folders.forEach(function(element, id, arr) {

            // If he's not a manager, do nothing
            AuthzAPI.hasRole(user.id, element.groupId, AuthzConstants.role.MANAGER, function(err, hasRole) {
                if(err) {
                    return callback(err);
                } 

                // Delete all his right and remove from library
                FolderAPI.removeFolderFromLibrary(ctx, user.id, element.id, true, function(err) {
                    if(err) {
                        return callback(err);
                    }
                    if(hasRole){

                        // Search if other user have right on this document
                        FolderAPI.getFolderMembers(ctx, element.id, null, null, function(err, memberList) {
                            if(err) {
                                return callback(err);
                            }

                            // If member list is empty - return
                            if(_.isEmpty(memberList)) { 
                                var update = {}; 
                                update[archiveUser.idArchive] = AuthzConstants.role.MANAGER;

                                // add manager permission to user archive
                                FolderAPI.setFolderPermissions(ctx, element.id, update, function(err, usersToInvalidate) {
                                    if(err) {
                                        return callback(err);
                                    }

                                    // Add the element to data archive
                                    PrincipalsDAO.addDataInArchive(archiveUser.idArchive, user.id, [element.id], function(err) {
                                        if(err) {
                                            return callback(err);
                                        }
                                        return callback(null);  
                                    });  
                                });
                            } 

                            // If there is member, analyze them....
                            var members = [];
                            var hasManager = false;

                            // If there is some members, look at his rights
                            memberList.forEach(function(person, idx, array) {

                                // If we have already find a manager, do nothing
                                if(hasManager) { return; }

                                // If he's manager, return and set hasmanager to true
                                if(person.role === AuthzConstants.role.MANAGER ) { 
                                    hasManager = true;
                                    return;
                                }  else {
                                    members.push(person.profile.id)
                                } 

                                // If it's the last iteration and we don't find any manager, promote all editor -> manager
                                if (idx === array.length - 1) { 
                                    if(!hasManager) {
                                        var update = {};
                                        
                                        members.forEach(function(member, idMember, arrayMember) {
                                            update[member] = AuthzConstants.role.MANAGER;

                                            // When no more editor, do update
                                            if (idMember === arrayMember.length - 1) { 
                                                FolderAPI.setFolderPermissions(ctx, element.id, update, function(err, usersToInvalidate) {
                                                    if(err) {
                                                        return callback(err);
                                                    }
                                                });
                                            };
                                        });
                                    }
                                }
                            });
                        });
                    }
                });
            });

            // When no more folder, return callback
            if (id === arr.length - 1) { 
                return callback(null);                    
            }
        });   
    });
};

/**
 * Delete rights on discussions && update roles on editors && update roles on user archive
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            The user to delete
 * @param  {String}     archiveUser     User Archive
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var _transferRightDiscussions = function(ctx, user, archiveUser, callback) {

    // Get all documents 
    DiscussionAPI.getDiscussionsLibrary(ctx, user.id, null, null, function(err, discussions) {
        if(err) {
            return callback(err);
        }
        if(_.isEmpty(discussions)) {
            return callback();
        }
        var contentIds = [];
        discussions.forEach(function(element, id, arr) {

            // If he's not a manager, do nothing
            AuthzAPI.hasRole(user.id, element.id, AuthzConstants.role.MANAGER, function(err, hasRole) {
                if(err) {
                    return callback(err);
                }

                // Delete all his right and remove from library
                DiscussionAPI.removeDiscussionFromLibrary(ctx, user.id, element.id, true, function(err) {
                    if(err) {
                        return callback(err);
                    }

                    if(hasRole) {

                        // Search if other user have right on this document
                        DiscussionAPI.getDiscussionMembers(ctx, element.id, null, null, function(err, memberList) {
                            if(err) {
                                return callback(err);
                            }

                            // If member list is empty - return
                            if(_.isEmpty(memberList)) { 
                                _addToArchive(archiveUser.idArchive, user.id, element.id, function(err){
                                    if(err) {
                                        return callback(err);
                                    }
                                }); 
                            } 

                            // Promote the user to the manager role
                            _promoteRoles(memberList, element, function(err) {
                                if(err) {
                                    return callback(err);
                                }
                            });
                        });
                    }
                });
            });

            // When no more folder, return callback
            if (id === arr.length - 1) { 
                return callback(null);                    
            }
        });   
    });
};

/**
 * Delete rights on groups && update roles on editors && update roles on user archive
 * Do not work, getMembershipsLibrary return undifined
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            The user to delete
 * @param  {String}     archiveUser     User Archive
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var _transferRightGroup = function(ctx, user, archiveUser, callback) {

    // Get all documents 
    GroupAPI.getMembershipsLibrary(ctx, user.id, null, null, function(err, groups) {
        if(err) {
            return callback(err);
        }
        if(_.isEmpty(groups)) {
            return callback();
        }
        var contentIds = [];
        groups.forEach(function(element, id, arr) {

            // If he's not a manager, do nothing
            AuthzAPI.hasRole(user.id, element.id, AuthzConstants.role.MANAGER, function(err, hasRole) {
                if(err) {
                    return callback(err);
                } 

                AuthzPermissions.canRemoveRole(ctx, user, element, false, function(err, memberChangeInfo) {
                    if (err) {
                        return callback(err);
                    }

                    AuthzAPI.updateRoles(group.id, memberChangeInfo.changes, function(err) {
                        if (err) {
                            return callback(err);
                        }

                        if(hasRole) {

                            // Search if other user have right on this document
                            GroupAPI.getMembersLibrary(ctx, element.id, null, null, function(err, memberList) {
                                if(err) {
                                    return callback(err);
                                }

                                // If there is no manager/member/editor delete it, else do nothing 
                                if(_.isEmpty(memberList)) { 
                                    _addToArchive(archiveUser.idArchive, user.id, element.id, function(err) {
                                        if(err) {
                                            return callback(err);
                                        }
                                    });                        
                                } 

                                // Promote the user to the manager role
                                _promoteRoles(memberList, element, function(err) {
                                    if(err) {
                                        return callback(err);
                                    }
                                });
                            });
                        }
                    });
                });
            });
            // When no more groups, return callback
            if (id === arr.length - 1) { 
                return callback();                    
            }
        });   
    });
};

/**
 * Remove all followers
 *
 * @param  {String}     user            The user to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var _deleteFollowers = function(user, callback) {

    // Remove following users
    FollowingDAO.getFollowing(user.id, null, null, function(err, userIds) {
        FollowingDAO.deleteFollows(user.id, userIds, function(err) {
            if(err) {
                return callback(err);
            }
            return;
        });
    });

    // Remove followers
    FollowingDAO.getFollowers(user.id, null, null, function(err, userIds) {
        userIds.forEach(function(id) {
            FollowingDAO.deleteFollows(id, user.id, function(err) {
                if(err) {
                    return callback(err);
                }
                return;
            });
        });
    });
};

/**
 * Add elements to archive (userless function)
 * TODO : remove it
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            The user to delete
 * @param  {String}     archiveUser     User Archive
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var _addToArchive = function(archiveUserId, principalId, elementId, callback) {

    if(!archiveUserId) {
        return callback(null);
    }

    if(!principalId) {
        return callback(null);
    }

    if(!elementId) {
        return callback(null);
    }

    var update = {}; 
    update[archiveUserId] = AuthzConstants.role.MANAGER;

    // Add role to UserArchive
    AuthzAPI.updateRoles(elementId, update, function(err, usersToInvalidate) {
        if(err) {
            return callback(err);
        }
    
        // Add the element to data archive
        PrincipalsDAO.addDataInArchive(archiveUserId, principalId, [elementId], function(err) {
            if(err) {
                return callback(err);
            }
            return callback(null);  
        });  
    });  
};

/**
 * Promote role -> member to manager
 *
 * @param  {ArrObject}  memberList      List of members
 * @param  {Object}     element         The resource 
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var _promoteRoles = function(memberList, element, callback) {
    var hasManager = false;
    var members = [];

    // If there is some members, look at his rights
    memberList.forEach(function(person, idx, array) {

        // If we have already find a manager || if is the deleted user, do nothing
        if(hasManager) { return; }

        // If he's manager, return and set hasManager to true
        if(person.role === AuthzConstants.role.MANAGER ) { 
            hasManager = true;
            return;
        } else {
            members.push(person.profile.id)
        } 

        // If it's the last iteration and we don't find any manager, promote all editor -> manager
        if (idx === array.length - 1) {
            if(!hasManager) {
                var update = {};

                members.forEach(function(member, idMember, arrayMember) {
                    update[member] = AuthzConstants.role.MANAGER;

                    // When no more editor, do update
                    if (idMember === arrayMember.length - 1) { 
                        AuthzAPI.updateRoles(element.id, update, function(err, usersToInvalidate){
                            if(err) {
                                return callback(err);
                            }
                        });
                    };
                });
            }
        }

        // When no more element, return callback
        if (idx === array.length - 1) { 
            return callback(null);                    
        }
    });
};

/**
 * Definitive delete of user
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            User that will be deleted
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var definitiveDeletion = module.exports.definitiveDeletion = function(ctx, user, alias, callback) {
    callback = callback || function() {};

    // Get userArchive
    PrincipalsDAO.getUserArchive(alias, user.id, function(err, userArchive) {
        if (err) {
            return callback(err);
        }

        // Delete all rights on resources
        _deleteRightResources(ctx, user, userArchive.idArchive, function(err) {
            if (err) {
                return callback(err);
            } 

            // Mark the user as deleted and deleted him
            PrincipalsDAO.deletePrincipal2(ctx, user, function(err) {
                if (err) {
                    return callback(err);
                }

                // Notify consumers that a user has been deleted
                log().info({'userId': user.id, 'name': 'oae-principals'}, 'Definitive deletion user with a mapped login id');

                // Notify that a user has been deleted
                PrincipalsEmitter.emit(PrincipalsConstants.events.DELETED_USER, ctx, user, function(err) {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, true);
                });
            });
        });
    });
};

/**
 * Remove all his rights on resources
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            The user to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var _deleteRightResources = function(ctx, user, idArchive, callback) {

    // Get all data from user archive where data belonged to the user removed
    PrincipalsDAO.getDataFromArchive(idArchive, user.id, function(err, ids) {
        if(err) {
            return callback(err);
        } 
        if(_.isEmpty(ids)) {
            return callback();
        }

        PrincipalsDAO.removeDataInArchive(idArchive, user.id, function(err) {
            if(err) {
                return callback(err);
            }

            ids.forEach(function(id) {

                // if the data belonged to the user removed, delete the resource
                if(id.principalId == user.id) {

                    // Get type of resource
                    var idSplite = id.idResources.split(':');

                    // Remove resources
                    switch(idSplite[0]) {
                        case "c" :
                            // Remove Contents
                            ContentAPI.deleteContent(ctx, id.idResources, function(err) {
                                if(err) {
                                    return callback(err);
                                }
                            });
                            break;

                        case "d" :
                            // Remove discussions
                            var update = {};
                            update[idArchive] = false;

                            // Update the authz associations
                            AuthzAPI.updateRoles(id.idResources, update, function(err) {
                                if (err) {
                                    return callback(err);
                                }

                                // Remove the actual discussion profile
                                DiscussionsDAO.deleteDiscussion(id.idResources, function(err, discussionId) {
                                    if (err) {
                                        return callback(err);
                                    }
                                });
                            });
                            break;

                        case "f" :
                            // Remove folders
                            FolderAPI.deleteFolder(ctx, id.idResources, true, function(err, content) {
                                if(err) {
                                    return callback(err);
                                }
                            });
                            break;

                        case "g" :
                            console.log('groups')
                            // Remove groups
                            PrincipalsDAO.deleteGroupFromPrincipals(element, function(err) {
                                if(err) {
                                    return callback(err);
                                }
                                console.log('group removed')
                            });
                            break;
                    }
                }
            });
            return callback(); 
        });
    });
};
