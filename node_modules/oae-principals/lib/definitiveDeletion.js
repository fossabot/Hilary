/*!
 * Copyright 2017 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the 'License'); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an 'AS IS'
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var fs = require('fs');
var shortId = require('shortId');
var util = require('util');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthenticationConstants = require('oae-authentication/lib/constants').AuthenticationConstants;
var Cassandra = require('oae-util/lib/cassandra');
var ConfigAPI = require('oae-config');
var ContentAPI = require('oae-content');
var ContentConfig = require('oae-config').config('oae-content');
var ContentConstants = require('oae-content/lib/constants').ContentConstants;
var ContentUtil = require('oae-content/lib/internal/util');
var Context = require('oae-context').Context;
var DiscussionAPI = require('oae-discussions/lib/api.discussions');
var DiscussionsDAO = require('oae-discussions/lib/internal/dao');
var EmailAPI = require('oae-email');
var FolderAPI = require('oae-folders');
var FolderLibraryDAO = require('oae-folders/lib/internal/foldersLibrary');
var FoldersConstants = require('oae-folders/lib/constants').FoldersConstants;
var FoldersDAO = require('oae-folders/lib/internal/dao');
var FollowingAPI = require('oae-following');
var FollowingConstants = require('oae-following/lib/constants').FollowingConstants;
var FollowingDAO = require('oae-following/lib/internal/dao');
var GroupAPI = require('./api.group');
var LoginId = require('oae-authentication/lib/model').LoginId;
var MeetingsAPI = require('oae-jitsi');
var MeetingAPI = require('oae-jitsi/lib/api.meetings'); // TODO(claire) : error when removing line and replace au MeetingAPI by MeetingsAPI
var MeetingsConstants = require('oae-jitsi/lib/constants').MeetingsConstants;
var MembersLibraryDAO = require('oae-content/lib/internal/membersLibrary');
var PrincipalsUtil = require('oae-principals/lib/util');
var ResourceActions = require('oae-resource/lib/actions');
var TenantsAPI = require('oae-tenants');
var TenantsUtil = require('oae-tenants/lib/util');

var PrincipalsAPI = require('./api.user');
var PrincipalsConfig = ConfigAPI.config('oae-principals');
var PrincipalsConstants = require('./constants').PrincipalsConstants;
var PrincipalsDAO = require('./internal/dao');
var PrincipalsEmitter = require('./internal/emitter');

var log = require('oae-logger').logger('oae-principals');

/**
 * Get or create user archive
 *
 * @param  {Context}    ctx                     Standard context object containing the current user and the current tenant
 * @param  {Object}     user                    User to be archived
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occured, if any
 * @param  {Object}     callback.userArchive    Return user archive
 */
var getOrCreateArchiveUser =  module.exports.getOrCreateArchiveUser = function(ctx, user, callback) {
    
    // Get and/or create archiveUser
    PrincipalsDAO.getArchivedUser(user.tenant.alias, function(err, userArchive) {
        if (err) {
            return callback(err);
        } else if (!_.isEmpty(userArchive)) {
            return callback(null, userArchive);
        } else {
            // Get email
            var emailDomains = user.tenant.emailDomains;

            // Persist the user object
            var userOpts = {
                'tenant': {'alias': user.tenant.alias},
                'visibility': 'public',
                'emailPreference': 'never',
                'locale':  ctx.locale(),
                'acceptedTC': null, 
                'isUserArchive' : 'true'
            };

            var displayName = user.tenant.alias + ' archive';

            // Create a record in the principals table
            PrincipalsAPI.createUser(ctx, user.tenant.alias, displayName, userOpts, function(err, createdUser) {
                if (err) {
                    return callback(err);
                }

                // Create a user archive in the table archiveByTenant
                PrincipalsDAO.createArchivedUser(user.tenant.alias, createdUser.id, function(err) {
                    if (err) {
                        return callback(err);
                    } 

                    // Get and return the userArchive
                    PrincipalsDAO.getArchivedUser(user.tenant.alias, function(err, userArchive) {
                        if (err) {
                            return callback(err);
                        }
                        return callback(null, userArchive);
                    });
                });
            });
        }
    });
};    

/**
 * Delete rights on a user + update roles on editors && on user archive
 *
 * @param  {Context}    ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}     user                    User that will be deleted
 * @param  {String}     archiveUsers            Users Archive
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occured, if any
 * @param  {Object}     callback.listEmail      Array of users to email
 */
var transferDataToArchive = module.exports.transferDataToArchive = function (ctx, user, archiveUsers, callback) {
    callback = callback || function() {};
    var listEmail = [];
    var listIdElement = [];

    // Delete/update roles in contents
    _transferRightToContent(ctx, user, archiveUsers, listEmail, listIdElement, function(err, listEmail, listIdElement) {
        if (err) {
            return callback(err);
        }

        // Delete/update roles in folders
        _transferRightToFolder(ctx, user, archiveUsers, listEmail, listIdElement, function(err, listEmail, listIdElement) {
            if (err) {
                return callback(err);
            } 

            // Delete/update roles in discussions
            _transferRightToDiscussions(ctx, user, archiveUsers, listEmail, listIdElement, function(err, listEmail, listIdElement) {
                if (err) {
                    return callback(err);
                }  

                // Delete/update roles in discussions
                _transferRightToMeetings(ctx, user, archiveUsers, listEmail, listIdElement, function(err, listEmail, listIdElement) {
                    if (err) {
                        return callback(err);
                    }  

                    // Delete/update roles in groups
                    _transferRightToGroup(ctx, user, archiveUsers, listEmail, listIdElement, function(err, listEmail, listIdElement) {
                        if (err) {
                            return callback(err);
                        }

                        // Add element to archive
                        _addToArchive(archiveUsers.archiveId, user.id, listIdElement, function(err) {
                            if(err) {
                                return callback(err);
                            }

                            // Delete followers and following
                            _deleteFollowers(ctx, user, function(err) {
                                if (err) {
                                    return callback(err);
                                }
                                _deleteFollowing(ctx, user, function(err) {
                                    if (err) {
                                        return callback(err);
                                    }

                                    // Send all emails
                                    _sendEmail(ctx, listEmail, function(err, listEmail) {
                                        if (err) {
                                            return callback(err);
                                        }
                                        
                                        return callback(null, listEmail);
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });            
};

/**
 * Send an email token to a user that have a resource shared with the deleted user
 *
 * @param  {data}       data            List of the user to send the email token to with the resource concerned
 * @param  {data}       idUserDeleted   Id of the user deleted
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
 // TODO(claire)
var _parseData = function(data, idUserDeleted, callback) {

    // values of deleted :
    //      userWillBePromoted : list of user (and resource concerned) who will recieve an email 'some user will be promoted'
    //      contentWillBeDeleted : list of user (and resource concerned) who will recieve an email 'resource will be removed'
    //      userJustLeaving : list of user (and resource concerned) who will recieve an email 'this user will leave the resource'

    if (_.isEmpty(data[0].memberList)) {
        return callback();
    }
    var listElementByMember = {'users': [] };

    // Fill the list with a first element
    listElementByMember.users.push({'userWillBePromoted': [], 'contentWillBeDeleted': [], 'userJustLeaving': [], 'profile': data[0].memberList[0].profile});
    
    var exist = false;

    // For each member/editor/... of a resource
    for (var i=0; i<=data.length; i++) { 

        // If last element, return
        if (i === data.length) {
            return callback(null, listElementByMember);
        }

        // There is a member list
        for (var k=0; k<data[i].memberList.length; k++) { 
            exist=false;

            // Create another list to sort by user the list of resource
            for (var j=0; j<listElementByMember.users.length; j++) { 

                if (data[i].memberList[k].profile.id !== idUserDeleted) {
                    // Add resource to user 
                    if ((listElementByMember.users[j].profile.id === data[i].memberList[k].profile.id)) {
                        exist=true;
                        if ((data[i].action === true) && (listElementByMember.users[j].userWillBePromoted.indexOf(data[i].resource) === -1)) {
                            listElementByMember.users[j].userWillBePromoted.push(data[i].resource);
                        } else if (data[i].action === false && (listElementByMember.users[j].contentWillBeDeleted.indexOf(data[i].resource) === -1)) {
                            listElementByMember.users[j].contentWillBeDeleted.push(data[i].resource);
                        } else if (data[i].action === null && (listElementByMember.users[j].userJustLeaving.indexOf(data[i].resource) === -1)) {
                            listElementByMember.users[j].userJustLeaving.push(data[i].resource);
                        }
                    }
                    // If user do not exist in the list, create it
                    else if ((listElementByMember.users.length === j+1) && (exist === false)) {
                        listElementByMember.users.push({'userWillBePromoted': [], 'contentWillBeDeleted': [], 'userJustLeaving': [], 'profile': data[i].memberList[k].profile});
                        if (data[i].action === true) {
                            listElementByMember.users[j+1].userWillBePromoted.push(data[i].resource);
                        } else if (data[i].action === false) {
                            listElementByMember.users[j+1].contentWillBeDeleted.push(data[i].resource);
                        } else if (data[i].action === null) {
                            listElementByMember.users[j+1].userJustLeaving.push(data[i].resource);
                        } 
                    }
                }
            }
        }
    }
};

/**
 * Send an email token to a user that have a resource shared with the deleted user
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Object}     data            User to send mail + resource
 * @param  {String}     [token]         The token to send. If left null, a new one will be generated
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var _sendEmail = function(ctx, data, callback) {

    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'user': user.id}, 'Unable to send a user a verification email');
        }
    };

    if (_.isEmpty(data)) {
        return callback();
    }

    var userDeleted = data[0].userDeleted;

    // Grab the configuration field. This will return the number of months 
    var month = PrincipalsConfig.getValue(ctx.tenant().alias, 'user', 'delete');
        
    // ParseData from variable informations to make an union on user
    _parseData(data, userDeleted.id, function(err, parseData) {

        if (err) {
            return callback(err);
        }

        if (_.isEmpty(parseData)) {
            return callback();
        }

        var listEmail = [];

        _.each(parseData.users, function(user, i, arrI) {

            // If there is no data, don't send mail
            if (_.isEmpty(user.userWillBePromoted) && _.isEmpty(user.contentWillBeDeleted) && _.isEmpty(user.userJustLeaving)) {
                if (i === arrI.length-1) { 
                    return callback(null, listEmail);
                }

            // Send an unique email to each user
            } else {

                // Generate a token if none was specified
                var token = shortId.generate();

                // Store the token
                PrincipalsDAO.storeEmailToken(user.profile.id, user.profile.email, token, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    resource = _.omit(user,'profile');
                    user = _.omit(user,['userWillBePromoted', 'contentWillBeDeleted', 'userJustLeaving']);

                    // The EmailAPI expects a user to have a verified email address. As this is not the case
                    // when sending an email token, we send in a patched user object
                    var userToEmail = _.extend({}, user, {'email': user.profile.email});
                    var tenant = TenantsAPI.getTenant(user.profile.tenant.alias);

                    // Send an email to the specified e-mail address
                    var dataEmail = {
                        'tenant': ctx.tenant(),
                        'userDeletedName': userDeleted.displayName,
                        'resource': resource,
                        'user': user,
                        'month': month,
                        'baseUrl': TenantsUtil.getBaseUrl(ctx.tenant()),
                        'skinVariables': require('oae-ui').getTenantSkinVariables(ctx.tenant().alias),
                        'token': token
                    };

                    // We pass the current date in as the 'hashCode' for this email. We need to be able to send
                    // a copy of the same email for the 'resend email token' functionality. As we don't expect
                    // that this logic will get stuck in a loop this is probably OK
                    EmailAPI.sendEmail('oae-principals', 'notify', userToEmail.profile, dataEmail, {'hash': Date.now()});
                    listEmail.push(user.profile.email);
                    
                    // Callback usefull for tests
                    if (i === arrI.length-1) { 
                        return callback(null, listEmail);
                    }
                });
            }
        });
    });
};

/**
 * Delete rights on contents + update roles on editors && on user archive
 *
 * @param  {Context}    ctx                         Standard context object containing the current user and the current tenant
 * @param  {String}     user                        User that will be deleted
 * @param  {String}     archiveUser                 User Archive
 * @param  {String}     listEmail                   Array of users to email
 * @param  {String}     listIdElement               List of element to remove from deleted user
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occured, if any
 * @param  {Array}      callback.listEmail          Array of users to email
 * @param  {Array}      callback.listIdElement      List of element to remove from deleted user
 * @api private
 */
var _transferRightToContent = function(ctx, user, archiveUser, listEmail, listIdElement, callback) {

    // Get all documents 
    ContentAPI.getContentLibraryItems(ctx, user.id, null, null, function(err, contents) {
        if (err) {
            return callback(err);
        }
        if (_.isEmpty(contents)) {
            return callback(null, listEmail, listIdElement);
        }
        
        // Recursive loop
        _transferRightToContentLoop(contents, ctx, user, archiveUser, listEmail, listIdElement, function(err, listEmail, listIdElement) {
            if (err) {
                return callback(err);
            }
            return callback(null, listEmail, listIdElement);
        }); 
    });
};

var _transferRightToContentLoop = function(contentHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, previousElement) {

    // Delete all his right on the previous element and remove it from library
    if (previousElement) {
        ContentAPI.removeContentFromLibrary(ctx, user.id, previousElement, function(err) {
            if (err) {
                return callback(err);
            }
        });
    }

    // Return when there are no more folder in the array
    if (!contentHashes || _.isEmpty(contentHashes)) {
        return callback(null, listEmail, listIdElement);
    }

    var element = contentHashes.shift();
    var update = {};

    // Search if other user have right on this document
    ContentAPI.getContentMembersLibrary(ctx, element.id, null, null, function(err, memberList) {
        if (err) {
            return callback(err);
        }

        // Get his role
        _doesUserHaveRoleManager(user.id, element.id, function(err, isManager) {
            if (err) {
                return callback(err);
            }

            // Remove the deleted user from the member list
            _removeDeletedUserFromArray(memberList, user.id, function(err, newMemberList) {
                if (err) {
                    return callback(err);
                }

                // If he's not a manager, do nothing, if else...
                if (isManager) {

                    // If member list is empty - return
                    if (_.isEmpty(newMemberList)) { 
                        listIdElement.push(element.id);
                        // Add to library
                        update[archiveUser.archiveId] = AuthzConstants.role.MANAGER;
                        ContentAPI.setContentPermissions(ctx, element.id, update, function() {
                            if (err) {
                                return callback(err);
                            }
                            // Recursive step inside the callback
                            return _transferRightToContentLoop(contentHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                        });

                    // If there is member, analyze them....
                    } else {
                        
                        // If there is members, look at his rights
                        var editors = _.filter(newMemberList, function(e) {
                            return e.role === AuthzConstants.role.EDITOR;
                        });

                        var hasManager = _.find(newMemberList, function(e) {
                            return e.role === AuthzConstants.role.MANAGER;
                        });

                        // If there is no editors and no manager, give to user archive -> manager role
                        if (_.isEmpty(editors) && !hasManager) {
                            
                            listEmail.push({'userDeleted': user, 'resource': element, 'memberList': newMemberList, 'action': false});
                            listIdElement.push(element.id);

                            // Add to user archive library
                            update[archiveUser.archiveId] = AuthzConstants.role.MANAGER;
                            ContentAPI.setContentPermissions(ctx, element.id, update, function(err) {
                                if (err) {
                                    return callback(err);
                                }
                                // Recursive step inside the callback
                                return _transferRightToContentLoop(contentHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                            });

                        // If it's the last iteration and we don't have manager(s), give to editors -> manager role
                        } else if (!hasManager) {
                            _.each(editors, function(editor, idEditor, arrayEditor) {

                                listEmail.push({'userDeleted': editor.profile.id, 'resource': element, 'memberList': newMemberList, 'action': true});

                                update[editor.profile.id] = AuthzConstants.role.MANAGER;

                                // When no more editor, do update
                                if (idEditor === arrayEditor.length-1) { 
                                    AuthzAPI.updateRoles(element.id, update, function(err, usersToInvalidate) {
                                        if (err) {
                                            return callback(err);
                                        }
                                        // Recursive step inside the callback
                                        return _transferRightToContentLoop(contentHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                                    });
                                }
                            });
                        } else {
                            // Recursive step inside the callback
                            return _transferRightToContentLoop(contentHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                        }
                    }
                } else {

                    listEmail.push({'userDeleted': user, 'resource': element, 'memberList': newMemberList, 'action': null});

                    // Recursive step inside the callback
                    return _transferRightToContentLoop(contentHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                      
                }
            });
        });   
    });
};

/**
 * Delete rights on folders + update roles on editors && on user archive
 *
 * @param  {Context}    ctx                         Standard context object containing the current user and the current tenant
 * @param  {String}     user                        The user to delete
 * @param  {String}     archiveUser                 User Archive
 * @param  {String}     listEmail                   Array of users to email
 * @param  {String}     listIdElement               List of element to remove from deleted user
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occured, if any
 * @param  {Array}      callback.listEmail          Array of users to email
 * @param  {Array}      callback.listIdElement      List of element to remove from deleted user
 * @api private
 */
var _transferRightToFolder = function(ctx, user, archiveUser, listEmail, listIdElement, callback) {

    // Get all documents 
    FolderAPI.getFoldersLibrary(ctx, user.id, null, null, function(err, folders) {
        if (err) {
            return callback(err);
        }
        if (_.isEmpty(folders)) {
            return callback(null, listEmail, listIdElement);
        }
        
        // Recursive loop
        _transferRightToFolderLoop(folders, ctx, user, archiveUser, listEmail, listIdElement, function(err, listEmail, listIdElement) {
            if (err) {
                return callback(err);
            }
            return callback(null, listEmail, listIdElement);
        }); 
    });
};

var _transferRightToFolderLoop = function(folderHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, previousElement) {

    // Delete all his right on the previous element and remove it from library
    if (previousElement) {
        FolderAPI.removeFolderFromLibrary(ctx, user.id, previousElement, function(err) {
            if (err) {
                return callback(err);
            }
        });
    }

    // Return when there are no more folder in the array
    if (!folderHashes || _.isEmpty(folderHashes)) {
        return callback(null, listEmail, listIdElement);
    }

    var element = folderHashes.shift();
    // Search if other user have right on this document
    FolderAPI.getFolderMembers(ctx, element.id, null, null, function(err, memberList) {
        if (err) {
            return callback(err);
        }

        // If he's not a manager, do nothing
        _doesUserHaveRoleManager(user.id, element.groupId, function(err, isManager) {
            if (err) {
                return callback(err);
            } 

            // Remove the deleted user from the member list
            _removeDeletedUserFromArray(memberList, user.id, function(err, newMemberList) {
                if (err) {
                    return callback(err);
                }
            
                if (isManager) {

                    // If member list is empty - return
                    if (_.isEmpty(newMemberList)) { 
                        listIdElement.push(element.id);

                        // Add right to user archive
                        var update = {}; 
                        update[archiveUser.archiveId] = AuthzConstants.role.MANAGER;

                        AuthzAPI.updateRoles(element.groupId, update, function(err) {
                            if (err) {
                                return callback(err);
                            }
                            AuthzAPI.updateRoles(element.id, update, function(err) {
                                if (err) {
                                    return callback(err);
                                }
                                // Recursive step inside the callback
                                return _transferRightToFolderLoop(folderHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                            });
                        });  
                    } else {

                        // If there is another manager on the resource, send a notification email, else promote others members
                        var hasAnotherManager = _.find(newMemberList, function(e) {
                            return e.role === AuthzConstants.role.MANAGER;
                        });

                        // Has manager
                        if (hasAnotherManager) {
                            listEmail.push({'userDeleted': user, 'resource': element, 'memberList': newMemberList, 'action': null});
                            // Recursive step inside the callback
                            return _transferRightToFolderLoop(folderHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);

                        // Has no manager
                        } else {
                            listEmail.push({'userDeleted': user, 'resource': element, 'memberList': newMemberList, 'action': true});
                            
                            // Promote the user to the manager role
                            _promoteRoles(newMemberList, element, function(err) {
                                if (err) {
                                    return callback(err);
                                }
                                // Recursive step inside the callback
                                return _transferRightToFolderLoop(folderHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                            });
                        }
                    }
                } else {
                    listEmail.push({'userDeleted': user, 'resource': element, 'memberList': memberList, 'action': null});
                    
                    // Recursive step inside the callback
                    return _transferRightToFolderLoop(folderHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                }
            });
        });
    });
};

/**
 * Delete rights on discussions + update roles on editors && on user archive
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            The user to delete
 * @param  {String}     archiveUser     User Archive
 * @param  {String}     listEmail       Array of users to email
 * @param  {String}     listIdElement   List of element to remove from deleted user
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _transferRightToDiscussions = function(ctx, user, archiveUser, listEmail, listIdElement, callback) {

    // Get all documents 
    DiscussionAPI.getDiscussionsLibrary(ctx, user.id, null, null, function(err, discussions) {
        if (err) {
            return callback(err);
        }
        if (_.isEmpty(discussions)) {
            return callback(null, listEmail, listIdElement);
        }
        
        // Recursive loop
        _transferRightToDiscussionsLoop(discussions, ctx, user, archiveUser, listEmail, listIdElement, function(err, listEmail, listIdElement) {
            if (err) {
                return callback(err);
            }
            return callback(null, listEmail, listIdElement);
        }); 
    });
};

var _transferRightToDiscussionsLoop = function(discussionHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, previousElement) {

    // Delete all his right on the previous element and remove it from library
    if (previousElement) {
        DiscussionAPI.removeDiscussionFromLibrary(ctx, user.id, previousElement, function(err) {
            if (err) {
                return callback(err);
            }
        });    
    }
   
    // Return when there are no more folder in the array
    if (!discussionHashes || _.isEmpty(discussionHashes)) {
        return callback(null, listEmail, listIdElement);
    }

    var element = discussionHashes.shift();

    // Search if other user have right on this document
    DiscussionAPI.getDiscussionMembers(ctx, element.id, null, null, function(err, memberList) {
        if (err) {
            return callback(err);
        }

        // If he's not a manager, do nothing
        _doesUserHaveRoleManager(user.id, element.id, function(err, isManager) {
            if (err) {
                return callback(err);
            }

            // Remove the deleted user from the member list
            _removeDeletedUserFromArray(memberList, user.id, function(err, newMemberList) {
                if (err) {
                    return callback(err);
                }

                if (isManager) {

                    // If member list is empty - return
                    if (_.isEmpty(newMemberList)) { 
                        listIdElement.push(element.id);

                        // Add the discussion to the library
                        var update = {}; 
                        update[archiveUser.archiveId] = AuthzConstants.role.MANAGER;
                        DiscussionAPI.setDiscussionPermissions(ctx, element.id, update, function(err) {
                            if (err) {
                                return callback(err);
                            }
                            // Recursive step inside the callback
                            return _transferRightToDiscussionsLoop(discussionHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                        }); 
                    } else {

                        // If there is another manager on the resource, send a notification email, else promote others members
                        var hasAnotherManager = _.find(newMemberList, function(e) {
                            return e.role === AuthzConstants.role.MANAGER;
                        });

                        // Has manager
                        if (hasAnotherManager) {
                            listEmail.push({'userDeleted': user, 'resource': element, 'memberList': newMemberList, 'action': null});
                            // Recursive step inside the callback
                            return _transferRightToDiscussionsLoop(discussionHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                        
                        // Has no manager
                        } else {
                            listEmail.push({'userDeleted': user, 'resource': element, 'memberList': newMemberList, 'action': true});

                            // Promote the user to the manager role
                            _promoteRoles(newMemberList, element, function(err) {
                                if (err) {
                                    return callback(err);
                                }
                                // Recursive step inside the callback
                                return _transferRightToDiscussionsLoop(discussionHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);                
                            });
                        }
                    }
                } else {Â 
                    listEmail.push({'userDeleted': user, 'resource': element, 'memberList': newMemberList, 'action': null});
                    // Recursive step inside the callback
                    return _transferRightToDiscussionsLoop(discussionHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                }
            });
        });
    });
};

/**
 * Delete rights on discussions + update roles on editors && on user archive
 *
 * @param  {Context}    ctx                         Standard context object containing the current user and the current tenant
 * @param  {String}     user                        The user to delete
 * @param  {String}     archiveUser                 User Archive
 * @param  {String}     listEmail                   Array of users to email
 * @param  {String}     listIdElement               List of element to remove from deleted user
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occured, if any
 * @param  {Array}      callback.listEmail          Array of users to email
 * @param  {Array}      callback.listIdElement      List of element to remove from deleted user
 * @api private
 */
var _transferRightToMeetings = function(ctx, user, archiveUser, listEmail, listIdElement, callback) {

    // Get all documents 
    MeetingAPI.getMeetingsLibrary(ctx, user.id, null, null, function(err, meetings) {

        if (err) {
            return callback(err);
        }

        if (_.isEmpty(meetings)) {
            return callback(null, listEmail, listIdElement);
        }
        
        // Recursive loop
        _transferRightToMeetingsLoop(meetings, ctx, user, archiveUser, listEmail, listIdElement, function(err, listEmail, listIdElement) {
            if (err) {
                return callback(err);
            }
            return callback(null, listEmail, listIdElement);
        }); 
    });
};

var _transferRightToMeetingsLoop = function(meetingHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, previousElement) {

    // Delete all his right on the previous element and remove it from library
    if (previousElement) {
        MeetingAPI.removeMeetingFromLibrary(ctx, user.id, previousElement, function(err) {
            if (err) {
                return callback(err);
            }
        });
    }

    // Return when there are no more folder in the array
    if (!meetingHashes || _.isEmpty(meetingHashes)) {
        return callback(null, listEmail, listIdElement);
    }

    var element = meetingHashes.shift();

    // Search if other user have right on this document
    MeetingAPI.getMeetingMembers(ctx, element.id, null, null, function(err, memberList) {
        if (err) {
            return callback(err);
        }

        // If he's not a manager, do nothing
        _doesUserHaveRoleManager(user.id, element.id, function(err, isManager) {
            if (err) {
                return callback(err);
            }

            // Remove the deleted user from the member list
            _removeDeletedUserFromArray(memberList, user.id, function(err, newMemberList) {
                if (err) {
                    return callback(err);
                }
                if (isManager) {

                    // If member list is empty - return
                    if (_.isEmpty(newMemberList)) { 
                        listIdElement.push(element.id);

                        var update = {}; 
                        update[archiveUser.archiveId] = AuthzConstants.role.MANAGER;
                        _setMeetingMembersNoVerif (ctx, element, update, function(err) {
                            if (err) {
                                return callback(err);
                            }

                            // Recursive step inside the callback
                            return _transferRightToMeetingsLoop(meetingHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                        });
                    } else {
                        
                        // If there is another manager on the resource, send a notification email, else promote others members
                        var hasAnotherManager = _.find(newMemberList, function(e) {
                            return e.role === AuthzConstants.role.MANAGER;
                        });

                        // Has manager
                        if (hasAnotherManager) {
                            listEmail.push({'userDeleted': user, 'resource': element, 'memberList': newMemberList, 'action': null});
                            
                            // Recursive step inside the callback
                            return _transferRightToMeetingsLoop(meetingHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                        
                        // Has no manager
                        } else {
                            listEmail.push({'userDeleted': user, 'resource': element, 'memberList': newMemberList, 'action': true});
                            
                            // Promote the user to the manager role
                            _promoteRoles(newMemberList, element, function(err) {
                                if (err) {
                                    return callback(err, listEmail);
                                }

                                // Recursive step inside the callback
                                return _transferRightToMeetingsLoop(meetingHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                            });
                        }
                    }
                } else {
                    listEmail.push({'userDeleted': user, 'resource': element, 'memberList': newMemberList, 'action': null});

                    // Recursive step inside the callback
                    return _transferRightToMeetingsLoop(meetingHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                }
            });
        });
    });
};

var _setMeetingMembersNoVerif = function(ctx, meeting, changes, callback) {

    ResourceActions.setRoles(ctx, meeting, changes, function (err, memberChangeInfo) {
        if (err) {
            return callback(err);
        }

        MeetingsAPI.emit(MeetingsConstants.events.UPDATED_MEETING_MEMBERS, ctx, meeting, memberChangeInfo, {}, function(errs) {
            if (errs) {
                return callback(_.first(errs));
            }

            return callback();
        });
    });
};

/**
 * Delete rights on groups + update roles on editors && on user archive
 *
 * @param  {Context}    ctx                         Standard context object containing the current user and the current tenant
 * @param  {String}     user                        The user to delete
 * @param  {String}     archiveUser                 User Archive
 * @param  {String}     listEmail                   Array of users to email
 * @param  {String}     listIdElement               List of element to remove from deleted user  
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occured
 * @param  {Array}      callback.listEmail          Array of users to email
 * @param  {Array}      callback.listIdElement      List of element to remove from deleted user
 * @api private
 */
var _transferRightToGroup = function(ctx, user, archiveUser, listEmail, listIdElement, callback) {

    // Get all documents 
    GroupAPI.getMembershipsLibrary(ctx, user.id, null, null, function(err, groups) {
        if (err) {
            return callback(err);
        }
        if (_.isEmpty(groups)) {
            return callback(null, listEmail, listIdElement);
        }
        
        // Recursive loop
        _transferRightToGroupLoop(groups, ctx, user, archiveUser, listEmail, listIdElement, function(err, listEmail, listIdElement) {
            if (err) {
                return callback(err);
            }
            return callback(null, listEmail, listIdElement);
        }); 
    });
};

var _transferRightToGroupLoop = function(groupHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, previousElement) {
    
    // Delete all his right on the previous element and remove it from library
    if (previousElement) {
        update = {}; 
        update[user.id] = false;
        AuthzAPI.updateRoles(previousElement, update, function(err) {
            if (err) {
                return callback(err);
            }
        });
    }

    // Return when there are no more folder in the array
    if (!groupHashes || _.isEmpty(groupHashes)) {
        return callback(null, listEmail, listIdElement);
    }

    var element = groupHashes.shift();
    var update = {}; 

    // Search if other user have right on this document
    GroupAPI.getMembersLibrary(ctx, element.id, null, null, function(err, memberList) {
        if (err) {
            return callback(err);
        }

        // If he's not a manager, do nothing
        _doesUserHaveRoleManager(user.id, element.id, function(err, isManager) {
            if (err) {
                return callback(err);
            } 

            // Remove the deleted user from the member list
            _removeDeletedUserFromArray(memberList, user.id, function(err, newMemberList) {
                if (err) {
                    return callback(err);
                }

                if (isManager) {

                    // If there is no manager/member/editor delete it, else do nothing 
                    if (_.isEmpty(newMemberList)) { 
                        listIdElement.push(element.id);

                        // Remove the right of deleted user
                        update = {}; 
                        update[user.id] = false;
                        AuthzAPI.updateRoles(element.id, update, function(err) {
                            if (err) {
                                return callback(err);
                            }
                            update = {}; 
                            update[archiveUser.archiveId] = AuthzConstants.role.MANAGER;

                            _setGroupMembersNoVerif (ctx, element, update, function(err) {
                                if (err) {
                                    return callback(err);
                                }

                                // Recursive step inside the callback
                                return _transferRightToGroupLoop(groupHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                            });
                        });
                    } else {

                        // If there is another manager on the resource, send a notification email, else promote others members
                        var hasAnotherManager = _.find(newMemberList, function(e) {
                            return e.role === AuthzConstants.role.MANAGER;
                        });

                        // Has manager
                        if (hasAnotherManager) {
                            listEmail.push({'userDeleted': user, 'resource': element, 'memberList': newMemberList, 'action': null});

                            // Recursive step inside the callback
                            return _transferRightToGroupLoop(groupHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                        
                        // Has no manager
                        } else {
                            listEmail.push({'userDeleted': user, 'resource': element, 'memberList': newMemberList, 'action': true});

                            // Promote the user to the manager role
                            _promoteRoles(newMemberList, element, function(err) {
                                if (err) {
                                    return callback(err);
                                }

                                // Recursive step inside the callback
                                return _transferRightToGroupLoop(groupHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                            });
                        }
                    }
                } else {
                    listEmail.push({'userDeleted': user, 'resource': element, 'memberList': newMemberList, 'action': null});

                    // Recursive step inside the callback
                    return _transferRightToGroupLoop(groupHashes, ctx, user, archiveUser, listEmail, listIdElement, callback, element.id);
                }        
            });
        });
    });
};

var _setGroupMembersNoVerif = function(ctx, group, changes, callback) {

    ResourceActions.setRoles(ctx, group, changes, function(err, memberChangeInfo) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(memberChangeInfo.changes)) {
            return callback();
        }

        PrincipalsUtil.touchLastModified(group, function(err, updatedGroup) {
            if (err) {
                return callback(err);
            }

            PrincipalsEmitter.emit(PrincipalsConstants.events.UPDATED_GROUP_MEMBERS, ctx, updatedGroup, group, memberChangeInfo, {}, function(errs) {
                if (errs) {
                    return callback(_.first(errs));
                }

                return callback();
            });
        });
    });
};

/**
 * Remove all following
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            The user to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _deleteFollowing = function(ctx, user, callback) {

    // Remove following users
    FollowingDAO.getFollowing(user.id, null, null, function(err, userIdsFollowing) {
        if (_.isEmpty(userIdsFollowing)) {
            return callback();
        }

        FollowingDAO.deleteFollows(user.id, userIdsFollowing, function(err) {
            if (err) {
                return callback(err);
            }

            var finish = 0;
            _.each(userIdsFollowing, function(id, i, arr) {

                FollowingAPI.emit(FollowingConstants.events.UNFOLLOW, ctx, ctx.user(), id, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    finish =+ 1;
                    if(finish === arr.length) {
                        return callback();
                    }
                });
            });
        });
    });
};

/**
 * Remove all followers
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            The user to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _deleteFollowers = function(ctx, user, callback) {
    
    // Remove followers
    FollowingDAO.getFollowers(user.id, null, null, function(err, userIdsFollowers) {
        if (_.isEmpty(userIdsFollowers)) {
            return callback();
        }

        var finish = 0;
        _.each(userIdsFollowers, function(id, i, arr) {
            
            FollowingDAO.deleteFollows(id, [user.id], function(err) {
                if (err) {
                    return callback(err);
                }

                PrincipalsDAO.getPrincipal(user.id, function(err, userUnfollowed) {
                    if (err) {
                        return callback(err);
                    }

                    FollowingAPI.emit(FollowingConstants.events.UNFOLLOW, ctx, userUnfollowed, user.id, function(err) {
                        if (err) {
                            return callback(err);
                        }

                        finish =+ 1;
                        if(finish === arr.length) {
                            return callback();
                        }
                    });
                });
            });
        });
    });
};

/**
 * Clear the list by removing the deleted user
 *
 * @param  {Array}      memberList                  Array of user
 * @param  {String}     userId                      User to delete from the array
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occured, if any
 * @param  {Object}     callback.newMemberList      Array of user without the deleted user
 * @api private
 */
var _removeDeletedUserFromArray = function(memberList, userId, callback) {
    return callback(null, _.reject(memberList, function(element) {
        return element.profile.id === userId;
    }));
};

/**
 * Add elements to archive
 *
 * @param  {String}     userArchiveId   The user archive of the tenant
 * @param  {String}     principalId     The id user to delete 
 * @param  {String}     elementId       The id element to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _addToArchive = function(userArchiveId, principalId, elementId, callback) {

    if (!userArchiveId || !principalId) {
        return callback(err);
    }
    if (!elementId) {
        return callback();
    }

    // Return list of ids after removing duplicate elements
    var duplicationRemoved = elementId.filter(function(elem, index, self) {
        return index == self.indexOf(elem);
    });

    // Add the element to data archive
    PrincipalsDAO.addDataToArchive(userArchiveId, principalId, duplicationRemoved, function(err) {
        if (err) {
            return callback(err);
        }
        return callback();  
    });  
};

/**
 * Promote role -> member to manager
 *
 * @param  {ArrObject}  memberList      List of members
 * @param  {Object}     element         The resource 
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _promoteRoles = function(memberList, element, callback) {
    var type = element.id.split(':')[0];
    var elementId = element.id; 

    if (type === 'f') {
        elementId = element.groupId;
    }

    var hasManager = false;
    var members = [];

    // If there is some members, look at his rights
    _.each(memberList, function(person, idx, array) {

        // If he's manager, return and set hasManager to true
        if (person.role === AuthzConstants.role.MANAGER) { 
            hasManager = true;
        } else {
            members.push(person.profile.id);
        } 

        // If it's the last iteration and we don't find any manager, promote all editor -> manager
        if (idx === array.length - 1) {

            if (!hasManager) {
                var update = {};

                _.each(members, function(member, idMember, arrayMember) {
                    update[member] = AuthzConstants.role.MANAGER;

                    // When no more editor, do update
                    if (idMember === arrayMember.length-1) { 
                        AuthzAPI.updateRoles(elementId, update, function(err, usersToInvalidate) {
                            if (err) {
                                return callback(err);
                            }
                            return callback();                    
                        });
                    }
                });
            } else {
                return callback();
            }
        }
    });
};

/**
 * Check if the current user is manager a content
 *
 * @param  {String}     userId              The user id 
 * @param  {String}     elementId           The resource id
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occured, if any
 * @param  {Boolean}    callback.hasRole    True if the user are manager of the content
 * @api private
 */
var _doesUserHaveRoleManager = function(userId, elementId, callback) {
    AuthzAPI.hasRole(userId, elementId, AuthzConstants.role.MANAGER, function(err, hasRole) {
        if (err) {
            return callback(err);
        }
        return callback(null, hasRole);
    });
};

/** =============================================================== **/
/** ===================== Definitive deletion ===================== **/
/** =============================================================== **/

/**
 * Definitive delete of user
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            User that will be deleted
 * @param  {String}     alias           Tenant alias
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var definitiveDeletion = module.exports.definitiveDeletion = function(ctx, user, alias, callback) {
    callback = callback || function() {};

    // Get userArchive
    PrincipalsDAO.getArchivedUser(alias, function(err, userArchive) {
        if (err) {
            return callback(err);
        }   

        // Delete all rights on resources
        _deleteResourceRights(ctx, user, userArchive.archiveId, function(err) {
            if (err) {
                return callback(err);
            } 

            // Remove profile picture from file system
            removeProfilePicture(ctx, user, function(err) {
                if (err) {
                    return callback(err);
                }

                // Mark the user as deleted and then, deleted him
                PrincipalsDAO.fullyDeletePrincipal(ctx, user, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Notify consumers that a user has been deleted
                    log().info({'userId': user.id, 'name': 'oae-principals'}, 'Definitive deletion user with a mapped login id');

                    // Notify that a user has been deleted
                    PrincipalsEmitter.emit(PrincipalsConstants.events.DELETED_USER, ctx, user, function(err) {
                        if (err) {
                            return callback(err);
                        }
                        return callback(null, true);
                    });
                });
            });
        });
    });
};

/**
 * Remove profile picture from file system
 *
 * @param  {String}     user            The user to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var removeProfilePicture = module.exports.removeProfilePicture = function(ctx, user, callback) {
    PrincipalsDAO.getPrincipal(user.id, function (err, principal) {
        if (err) {
            return callback(err);
        }

        if (_.isEmpty(principal.picture)) {
            return callback();
        } else {
            // Remove profile picture
            var pathSmallPicture = principal.picture.smallUri.split(':');
            var pathMediumPicture = principal.picture.mediumUri.split(':');
            var pathLargePicture = principal.picture.largeUri.split(':');

            var path = ContentUtil.getStorageBackend(ctx, principal.picture.largeUri).getRootDirectory();

            fs.unlink(path + '/' + pathSmallPicture[1]);
            fs.unlink(path + '/' + pathMediumPicture[1]);
            fs.unlink(path + '/' + pathLargePicture[1]);

            return callback();
        }
    });
};

/**
 * Remove all his rights on resources
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            The user to delete
 * @param  {String}     archiveId       The user archive of the tenant
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _deleteResourceRights = function(ctx, user, archiveId, callback) {

    // Get all data from user archive where data belonged to the user removed
    PrincipalsDAO.getDataFromArchive(archiveId, user.id, function(err, data) {
        if (err) {
            return callback(err);
        } 
        if (_.isEmpty(data)) {
            return callback();
        } else {

            var ids = data.resourceId.split(',');

            // Remove the data from the table 'DataArchive'
            PrincipalsDAO.removeDataInArchive(archiveId, user.id, function(err) {
                if (err) {
                    return callback(err);
                }    

                // If there is no ids, return callback
                if (ids.length !== 0) {
                    _.each(ids, function(id, i, arr) {

                        // if the data belonged to the removed user, delete the resource
                        if (data.principalId === user.id) {
                            
                            // Get type of resource
                            var idResource = id;
                            var splitId = idResource.split(':');

                            // If it's a folder get the idGroup
                            _ifFolderGetIdGroup(ctx, idResource, splitId[0], function(err, idFolder) {
                                if (err) {
                                    return callback(err);
                                }
                                if (idFolder) {
                                    idResource = idFolder;
                                }
                                
                                // Get role
                                AuthzAPI.getAllAuthzMembers(idResource, function(err, memberIdRoles) {

                                    var managers = 0;
                                    var rolesMember = _.pluck(memberIdRoles, 'role');

                                    _.each(rolesMember, function(role) {
                                        if (role === AuthzConstants.role.MANAGER) {
                                            managers = managers + 1;
                                        }
                                    });
                                    
                                    var del = managers > 1 ? false : true;

                                    // Remove the resource with the appropriate method
                                    switch(splitId[0]) {
                                        case 'c':
                                            _deleteRightToContent(ctx, del, archiveId, idResource, function(err) {
                                                if (err) {
                                                    return callback(err);
                                                }
                                            });
                                            break;
                                        case 'd':
                                            _deleteRightToDiscussion(ctx, del, archiveId, idResource, function(err) {
                                                if (err) {
                                                    return callback(err);
                                                }
                                            });
                                            break;
                                        case 'f':
                                            _deleteRightToFolder(ctx, del, archiveId, id, function(err) {
                                                if (err) {
                                                    return callback(err);
                                                }
                                            });
                                            break;
                                        case 'g':
                                            _deleteRightToGroup(ctx, del, archiveId, idResource, function(err) {
                                                if (err) {
                                                    return callback(err);
                                                }
                                            });
                                            break;
                                        case 'm':
                                            _deleteRightToMeeting(ctx, del, archiveId, idResource, function(err) {
                                                if (err) {
                                                    return callback(err);
                                                }
                                            });
                                            break;
                                    }
                                });
                            });
                        }
                        if (i === arr.length-1) {
                            return callback();
                        }
                    });
                }
            });
        }
    });
};

/**
 * Remove right on content or remove it if there is no manager 
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     idResource      The id of the resource to delete
 * @param  {String}     splitId        The first part of a resource id (e.g. f:test:ryfQL_D4b, it will be 'f') who define the type of resource
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _ifFolderGetIdGroup = function(ctx, idResource, splitId, callback) {
    if (splitId == 'f') {
        FolderAPI.getFolder(ctx, idResource, function(err, folder) {Â 
            if (err) {
                return callback(err);
            }
            return callback(null, folder.groupId);
        });
    } else {
        return callback();
    }
};

/**
 * Remove right on content or remove it if there is no manager 
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Boolean}    del             Boolean who determine if the element should be remove or just removed from the library
 * @param  {String}     archiveId       The id user archive of the tenant
 * @param  {String}     idResource      The id of the resource to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _deleteRightToContent = function(ctx, del, archiveId, idResource, callback) {
    if (del) {
        // Remove content
        ContentAPI.deleteContent(ctx, idResource, function(err) {
            if (err) {
                return callback(err);
            }
            return callback();
        });
    } else {
        // If there is another manager on the content, remove it from the library
        ContentAPI.removeContentFromLibrary(ctx, archiveId, idResource, function(err) {
            if (err) {
                return callback(err);
            }
            return callback();
        });
    }
};

/**
 * Remove right on discussion or remove it if there is no manager 
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Boolean}    del             Boolean who determine if the element should be remove or just removed from the library
 * @param  {String}     archiveId       The id user archive of the tenant
 * @param  {String}     idResource      The id of the resource to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _deleteRightToDiscussion = function(ctx, del, archiveId, idResource, callback) {
    if (del) {
        // Remove the actual discussion profile
        DiscussionAPI.deleteDiscussion(ctx, idResource, function(err) {
            if (err) {
                return callback(err);
            }
            return callback();
        });
    } else {
        // If there is another manager on the discussion, remove it from the library
        DiscussionAPI.removeDiscussionFromLibrary(ctx, archiveId, idResource, function(err) {
            if (err) {
                return callback(err);
            }
            return callback();
        });        
    }
};

/**
 * Remove right on folder or remove it if there is no manager 
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Boolean}    del             Boolean who determine if the element should be remove or just removed from the library
 * @param  {String}     archiveId       The id user archive of the tenant
 * @param  {String}     idResource      The id of the resource to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _deleteRightToFolder = function(ctx, del, archiveId, idResource, callback) {
    if (del) {
        // Remove folder
        FolderAPI.deleteFolder(ctx, idResource, false, function(err, content) {
            if (err) {
                return callback(err);
            }
            return callback();
        });
    } else {
        // If there is another manager on the folder, remove it from the library
        FolderAPI.removeFolderFromLibrary(ctx, archiveId, idResource, function(err) {
            if (err) {
                return callback(err);
            }
            return callback();
        });
    }
};

/**
 * Remove right on group or remove it if there is no manager 
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Boolean}    del             Boolean who determine if the element should be remove or just removed from the library
 * @param  {String}     archiveId       The id user archive of the tenant
 * @param  {String}     idResource      The id of the resource to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _deleteRightToGroup = function(ctx, del, archiveId, idResource, callback) {
    if (del) {
        // Remove group
        GroupAPI.deleteGroup(ctx, idResource, function(err) {
            if (err) {
                return callback(err);
            }
            // Remove roles
            var update = {};
            update[archiveId] = false;
            AuthzAPI.updateRoles(idResource, update, function(err, usersToInvalidate) {
                if (err) {
                    return callback(err);
                }
                return callback();                    
            });
        });
    } else {
        // If there is another manager on the group, remove it from the library
        GroupAPI.leaveGroup(ctx, idResource, function(err) {
            if (err) {
                return callback(err);
            }
            return callback();
        });
    }
};

/**
 * Remove right on meeting or remove it if there is no manager 
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Boolean}    del             Boolean who determine if the element should be remove or just removed from the library
 * @param  {String}     archiveId       The id user archive of the tenant
 * @param  {String}     idResource      The id of the resource to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _deleteRightToMeeting = function(ctx, del, archiveId, idResource, callback) {
    if (del) {
        // Remove meeting
        MeetingAPI.deleteMeeting(ctx, idResource, function(err) {
            if (err) {
                return callback(err);
            }
            return callback();
        });
    } else {
        // If there is another manager on the meeting, remove it from the library
        MeetingAPI.removeMeetingFromLibrary(ctx, archiveId, idResource, function(err) {
            if (err) {
                return callback(err);
            }
            return callback();
        });
    }
};
