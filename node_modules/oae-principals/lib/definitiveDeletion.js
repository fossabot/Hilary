/*!
 * Copyright 2017 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');

var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var Cassandra = require('oae-util/lib/cassandra');
var Context = require('oae-context').Context;
var log = require('oae-logger').logger('oae-principals');
var LoginId = require('oae-authentication/lib/model').LoginId;
var TenantsUtil = require('oae-tenants/lib/util');
var ShortId = require('shortid');
var AuthenticationConstants = require('oae-authentication/lib/constants').AuthenticationConstants;
var ResourceActions = require('oae-resource/lib/actions');
var PrincipalsUtil = require('oae-principals/lib/util');
var FoldersConstants = require('oae-folders/lib/constants').FoldersConstants;
var MeetingsConstants = require('oae-jitsi/lib/constants').MeetingsConstants;
var MeetingsAPI = require('oae-jitsi');

// API
var ConfigAPI = require('oae-config');
var TenantsAPI = require('oae-tenants');
var ContentAPI = require('oae-content');
var AuthzAPI = require('oae-authz');
var FolderAPI = require('oae-folders');
var DiscussionAPI = require('oae-discussions/lib/api.discussions');
var GroupAPI = require('./api.group');
var MeetingAPI = require('oae-jitsi/lib/api.meetings');
var EmailAPI = require('oae-email');

// DAO
var FollowingDAO = require('oae-following/lib/internal/dao');
var DiscussionsDAO = require('oae-discussions/lib/internal/dao');
var MembersLibraryDAO = require('oae-content/lib/internal/membersLibrary');
var FolderLibraryDAO = require('oae-folders/lib/internal/foldersLibrary');
var FoldersDAO = require('oae-folders/lib/internal/dao');

// PRINCIPALS
var PrincipalsConfig = ConfigAPI.config('oae-principals');
var PrincipalsConstants = require('./constants').PrincipalsConstants;
var PrincipalsDAO = require('./internal/dao');
var PrincipalsAPI = require('./api.user');
var PrincipalsEmitter = require('./internal/emitter');


/**
 * Get or create user archive
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Object}     user            User
 * @param  {String}     defaultValue    The default value returned in case of no result
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var getOrCreateArchiveUser =  module.exports.getOrCreateArchiveUser = function(ctx, user, callback) {
    
    // Get and/or create archiveUser
    PrincipalsDAO.getUserArchive(user.tenant.alias, function(err, userArchive) {
        if(err) {
            return callback(err);

        } else if (_.isEmpty(userArchive)) {
            // Get email
            emailDomains = user.tenant.emailDomains;

            // Get tenant
            tenant = TenantsAPI.getTenantsForEmailDomains(emailDomains);
            tenant = tenant[emailDomains];

            // Persist the user object
            var userOpts = {
                'tenant': {'alias': tenant.alias},
                'visibility': 'public',
                'email': tenant.alias + 'Archive@' + emailDomains[0],
                'emailPreference': 'immediate',
                'locale':  ctx.locale(),
                'acceptedTC': null
            };

            var displayName = tenant.alias + ' archive';

            var loginId = new LoginId(tenant.alias, AuthenticationConstants.providers.LOCAL, tenant.alias + 'Archive', {'password': 'password'});
            // Create table in the principals table
            PrincipalsAPI.createUser(ctx, tenant.alias, displayName, userOpts, function(err, createdUser) {
                if(err) {
                    return callback(err);
                }

                // Create a user archive in the table archiveByTenant
                PrincipalsDAO.createUserArchive(user.tenant.alias, createdUser.id, function(err) {
                    if(err) {
                        return callback(err);
                    } 

                    // Get and return the userArchive
                    PrincipalsDAO.getUserArchive(user.tenant.alias, function(err, userArchive) {
                        if(err) {
                            return callback(err);
                        }
                        return callback(null, userArchive);
                    });
                });
            });

        } else {
            return callback(null, userArchive);
        }
    });
};    

/**
 * Get a configuration
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     configkey       The config key to get the value of key
 * @param  {String}     defaultValue    The default value returned in case of no result
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var getConfig = module.exports.getConfig = function(ctx, configkey, defaultValue, callback) {
    if (_.isEmpty(ctx)) {
        return callback(null, []);
    }

    Cassandra.runQuery('SELECT "value" FROM "Config" WHERE "tenantAlias" = ? AND "configKey" = ?', [ctx.tenant().alias, configkey], function(err, result) {
        if (err) {
            return callback(err);
        }

        if (_.isEmpty(result)) {
            return callback(null, defaultValue);
            
        } else {
            res = _.chain(result).map(Cassandra.rowToHash)._wrapped[0];
            return callback(null, res.value);
        }
    });
};

/**
 * Delete rights on a user + update roles on editors && on user archive
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            User that will be deleted
 * @param  {String}     archiveUser     User Archive
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var transferDataToArchive = module.exports.transferDataToArchive = function (ctx, user, archiveUser,callback) {
    callback = callback || function() {};

    // Transfer or update rights in contents
    _transferRightContent(ctx, user, archiveUser, function(err) {
        if (err) {
            return callback(err);
        }

        // Transfer or update rights in folders
        _transferRightFolder(ctx, user, archiveUser, function(err) {
            if (err) {
                return callback(err);
            } 

            // Transfer or update rights in discussions
            _transferRightDiscussions(ctx, user, archiveUser, function(err) {
                if (err) {
                    return callback(err);
                }  

                // Transfer or update rights in discussions
                _transferRightMeetings(ctx, user, archiveUser, function(err) {
                    if (err) {
                        return callback(err);
                    }  

                    // Transfer or update rights in groups
                    _transferRightGroup(ctx, user, archiveUser, function(err) {
                        if (err) {
                            return callback(err);
                        }

                        // Delete rights in followers
                        _deleteFollowers(user, function(err) {
                            if (err) {
                                return callback(err);
                            }
                            return callback();
                        });
                    });
                });
            });
        });
    });            
};

/**
 * Delete rights on contents + update roles on editors && on user archive
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            User that will be deleted
 * @param  {String}     archiveUser     User Archive
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _transferRightContent = function(ctx, user, archiveUser, callback) {

    // Get all documents 
    ContentAPI.getContentLibraryItems(ctx, user.id, null, null, function(err, contents) {
        if(err) {
            return callback(err);
        }
        if(_.isEmpty(contents)) {
            return callback();
        }
        var contentIds = [];
        var finish = 0;
        contents.forEach(function(element, id, arr) {

            // Get his role
            AuthzAPI.hasRole(user.id, element.id, AuthzConstants.role.MANAGER, function(err, hasRole) {
                if(err) {
                    return callback(err);
                }

                // If he's not a manager, do nothing, if else...
                if(hasRole) {

                    // Search if other user have right on this document
                    ContentAPI.getContentMembersLibrary(ctx, element.id, null, null, function(err, memberList) {
                        if(err) {
                            return callback(err);
                        }

                        // Remove the deleted user from the member list
                        _deleteManagerArray(memberList, user.id, function(err, newMemberList) {
                            if(err) {
                                return callback(err);
                            }

                            // If member list is empty - return
                            if(_.isEmpty(newMemberList)) { 
                                _addToArchive(archiveUser.idArchive, user.id, element.id, function(err) {
                                    if(err) {
                                        return callback(err);
                                    }

                                    // Add to library
                                    var update = {};
                                    update[archiveUser.idArchive] = AuthzConstants.role.MANAGER;
                                    ContentAPI.setContentPermissions(ctx, element.id, update, function() {
                                        if(err) {
                                            return callback(err);
                                        }

                                        // Delete all his right and remove from library
                                        ContentAPI.removeContentFromLibrary(ctx, user.id, element.id, function(err) {
                                            finish ++;
                                            // When no more content, return callback
                                            if (contents.length === finish) { 
                                                return callback(null);                    
                                            }
                                        });
                                    });
                                }); 
                            } 

                            // If there is member, analyze them....
                            var editors = [];
                            var hasManager = false;

                            // If there is some members, look at his rights
                            for (i = 0; i <= newMemberList.length; i++) { 
                                
                                // If it's not the last iteration ...
                                if (i < newMemberList.length) { 

                                    // ... and if he's manager, return and set hasmanager to true
                                    if (newMemberList[i].role === AuthzConstants.role.MANAGER ) {  
                                        hasManager = true;
                                    }  
                                    
                                    // ... and if he's editor, add to editors list
                                    if (newMemberList[i].role === AuthzConstants.role.EDITOR) {
                                        editors.push(newMemberList[i].profile.id)
                                    }

                                // If it's the last iteration and we don't find any manager, promote all editor -> manager
                                } else { 
                                    _sendEmail(ctx, user, element, newMemberList, _.isEmpty(editors) && !hasManager, function(err) {
                                        if(err) {
                                            return callback(err);
                                        }
                                        //console.log('mail sent ok')
                                    });

                                    if (_.isEmpty(editors) && !hasManager) {
                                        _addToArchive(archiveUser.idArchive, user.id, element.id, function(err) {
                                            if(err) {
                                                return callback(err);
                                            }
                                        });  

                                        // Add to user archive library
                                        var update = {};
                                        update[archiveUser.idArchive] = AuthzConstants.role.MANAGER;
                                        ContentAPI.setContentPermissions(ctx, element.id, update, function() {
                                            if(err) {
                                                return callback(err);
                                            }
                                            // Delete all his right and remove from library
                                            ContentAPI.removeContentFromLibrary(ctx, user.id, element.id, function(err) {
                                                finish ++;
                                                // When no more content, return callback
                                                if (contents.length === finish) { 
                                                    return callback(null);                    
                                                }
                                            });
                                        });

                                    // If it's the last iteration and we don't have manager(s), give to user archive -> manager role
                                    } else if (!hasManager) {
                                        var update = {};
                                        editors.forEach(function(editor, idEditor, arrayEditor) {
                                            
                                            update[editor] = AuthzConstants.role.MANAGER;

                                            // When no more editor, do update
                                            if (idEditor === arrayEditor.length - 1) { 
                                                AuthzAPI.updateRoles(element.id, update, function(err, usersToInvalidate) {
                                                    if(err) {
                                                        return callback(err);
                                                    }
                                                    // Delete all his right and remove from library
                                                    ContentAPI.removeContentFromLibrary(ctx, user.id, element.id, function(err) {
                                                        finish ++;
                                                        // When no more content, return callback
                                                        if (contents.length === finish) { 
                                                            return callback(null);                    
                                                        }
                                                    });
                                                });
                                            };
                                        });
                                    } else {
                                        // Delete all his right and remove from library
                                        ContentAPI.removeContentFromLibrary(ctx, user.id, element.id, function(err) {
                                            finish ++;
                                            // When no more content, return callback
                                            if (contents.length === finish) { 
                                                return callback(null);                    
                                            }
                                        });   
                                    }
                                }
                            }
                           // });
                        });
                    });
                } else {
                    // Delete all his right and remove from library
                    ContentAPI.removeContentFromLibrary(ctx, user.id, element.id, function(err) {
                        finish ++;
                        // When no more content, return callback
                        if (contents.length === finish) { 
                            return callback(null);                    
                        }
                    });   
                }
            });
        });   
    });
};

/**
 * Send an email token to a user that have a resource shared with the deleted user
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Users}      memberList      List of the user to send the email token to
 * @param  {User}       user            User that will be deleted
 * @param  {String}     resource        Resource concerned
 * @param  {Boolean}    deleted         True if the resource will be deleted
 * @param  {String}     [token]         The token to send. If left null, a new one will be generated
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var _sendEmail = function(ctx, user, element, memberList, deleted, callback) {

    // Get configuration
    getConfig(ctx, "oae-principals/user/delete", 2, function (err, month) {
        if(err) {
            return callback(err);
        }

        // For each member/editor/... of the resource, ...
        memberList.forEach(function(person) { 

            // ... send him warning email 
            _sendWarnEmail(ctx, user, element, person, deleted, month, function(err) {
                if(err) {
                    return callback(err);
                }
                //console.log('email sent')
            }); 
        });
    });
};

/**
 * Send an email token to a user that have a resource shared with the deleted user
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {User}       person          The user to send the email token to
 * @param  {User}       user            User that will be deleted
 * @param  {String}     resource        Resource concerned
 * @param  {Boolean}    deleted         True if the resource will be deleted
 * @param  {String}     month           Time until definitive deletion
 * @param  {String}     [token]         The token to send. If left null, a new one will be generated
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
 // TODO : send just one email for each user
var _sendWarnEmail = function(ctx, user, resource, person, deleted, month, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'user': user.id}, 'Unable to send a user a verification email');
        }
    };

    // Generate a token if none was specified
    token = ShortId.generate();

    // Store the token
    PrincipalsDAO.storeEmailToken(person.profile.id, person.profile.email, token, function(err) {
        if (err) {
            return callback(err);
        }

        // The EmailAPI expects a user to have a verified email address. As this is not the case
        // when sending an email token, we send in a patched user object
        var userToEmail = _.extend({}, person, {'email': person.profile.email});

        var tenant = TenantsAPI.getTenant(person.profile.tenant.alias);
        var verificationUrl = TenantsUtil.getBaseUrl(tenant) + '/?notifyEmail=' + encodeURIComponent(token);

        //console.log(month)
        // Send an email to the specified e-mail address
        var data = {
            'tenant': ctx.tenant(),
            'userDeleted': user,
            'resource': resource,
            'user': userToEmail,
            'deleted': deleted,
            'month': month,
            'baseUrl': TenantsUtil.getBaseUrl(ctx.tenant()),
            'skinVariables': require('oae-ui').getTenantSkinVariables(ctx.tenant().alias),
            'token': token,
            'verificationUrl': verificationUrl
        };

        // We pass the current date in as the "hashCode" for this email. We need to be able to send
        // a copy of the same email for the "resend email token" functionality. As we don't expect
        // that this logic will get stuck in a loop this is probably OK
        EmailAPI.sendEmail('oae-principals', 'notify', userToEmail.profile, data, {'hash': Date.now()});

        return callback();
    });
};

/**
 * Delete rights on folders + update roles on editors && on user archive
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            The user to delete
 * @param  {String}     archiveUser     User Archive
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _transferRightFolder = function(ctx, user, archiveUser, callback) {

    // Get all documents 
    FolderAPI.getFoldersLibrary(ctx, user.id, null, null, function(err, folders) {
        if(err) {
            return callback(err);
        }
        if(_.isEmpty(folders)) {
            return callback();
        }
        var contentIds = [];
        var finish = 0;
        folders.forEach(function(element, id, arr) {

            // If he's not a manager, do nothing
            AuthzAPI.hasRole(user.id, element.groupId, AuthzConstants.role.MANAGER, function(err, hasRole) {
                if(err) {
                    return callback(err);
                } 
                
                if(hasRole) {

                    // Search if other user have right on this document
                    FolderAPI.getFolderMembers(ctx, element.id, null, null, function(err, memberList) {
                        if(err) {
                            return callback(err);
                        }

                        // Remove the deleted user from the member list
                        _deleteManagerArray(memberList, user.id, function(err, newMemberList) {
                            if(err) {
                                return callback(err);
                            }

                            // If member list is empty - return
                            if(_.isEmpty(newMemberList)) { 

                                 _addToArchive(archiveUser.idArchive, user.id, element.id, function(err) {
                                    if(err) {
                                        return callback(err);
                                    }

                                    // Add right to user archive
                                    var update = {}; 
                                    update[archiveUser.idArchive] = AuthzConstants.role.MANAGER;

                                    AuthzAPI.updateRoles(element.groupId, update, function(err) {
                                        if(err) {
                                            return callback(err);
                                        }

                                        // Remove right to deleted user
                                        FolderAPI.removeFolderFromLibrary(ctx, user.id, element.id, function(err) {
                                            finish ++;
                                            // When no more groups, return callback
                                            if (folders.length === finish) { 
                                                return callback(null);                    
                                            }
                                        });
                                    });  
                                });  
                            } else {

                                // Promote the user to the manager role
                                _promoteRoles(newMemberList, element, function(err) {
                                    if(err) {
                                        return callback(err);
                                    }

                                    // Delete all his right and remove from library
                                    FolderAPI.removeFolderFromLibrary(ctx, user.id, element.id, function(err) {
                                        finish ++;
                                        // When no more folders, return callback
                                        if (folders.length === finish) { 
                                            return callback(null);                    
                                        }
                                    });
                                });
                            }
                        });
                    });
                } else { 

                    // Delete all his right and remove from library
                    FolderAPI.removeFolderFromLibrary(ctx, user.id, element.id, function(err) {
                        finish ++;

                        // When no more folders, return callback
                        if (folders.length === finish) { 
                            return callback(null);                    
                        }
                    });
                }
            });
        });   
    });
};

/**
 * Delete rights on discussions + update roles on editors && on user archive
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            The user to delete
 * @param  {String}     archiveUser     User Archive
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _transferRightDiscussions = function(ctx, user, archiveUser, callback) {

    // Get all documents 
    DiscussionAPI.getDiscussionsLibrary(ctx, user.id, null, null, function(err, discussions) {
        if(err) {
            return callback(err);
        }
        if(_.isEmpty(discussions)) {
            return callback();
        }
        var contentIds = [];
        var finish = 0;
        discussions.forEach(function(element, id, arr) {

            // If he's not a manager, do nothing
            AuthzAPI.hasRole(user.id, element.id, AuthzConstants.role.MANAGER, function(err, hasRole) {
                if(err) {
                    return callback(err);
                }

                if(hasRole) {

                    // Search if other user have right on this document
                    DiscussionAPI.getDiscussionMembers(ctx, element.id, null, null, function(err, memberList) {
                        if(err) {
                            return callback(err);
                        }

                        // Remove the deleted user from the member list
                        _deleteManagerArray(memberList, user.id, function(err, newMemberList) {
                            if(err) {
                                return callback(err);
                            }

                            // If member list is empty - return
                            if(_.isEmpty(newMemberList)) { 
                                _addToArchive(archiveUser.idArchive, user.id, element.id, function(err) {
                                    if(err) {
                                        return callback(err);
                                    }
                                }); 

                                // Add the discussion to the library
                                var update = {}; 
                                update[archiveUser.idArchive] = AuthzConstants.role.MANAGER;
                                DiscussionAPI.setDiscussionPermissions(ctx, element.id, update, function(err) {
                                    if(err) {
                                        return callback(err);
                                    }

                                    // Delete all his right and remove from library
                                    DiscussionAPI.removeDiscussionFromLibrary(ctx, user.id, element.id, function(err) {
                                        finish ++;
                                        // When no more discussions, return callback
                                        if (discussions.length === finish) { 
                                            return callback(null);                    
                                        }
                                    });
                                }); 
                            } else {

                                // Promote the user to the manager role
                                _promoteRoles(newMemberList, element, function(err) {
                                    if(err) {
                                        return callback(err);
                                    }

                                    // Delete all his right and remove from library
                                    DiscussionAPI.removeDiscussionFromLibrary(ctx, user.id, element.id, function(err) {
                                        finish ++;
                                        // When no more discussions, return callback
                                        if (discussions.length === finish) { 
                                            return callback(null);                    
                                        }
                                    });
                                });
                            }
                        });
                    });
                } else { 
                    // Delete all his right and remove from library
                    DiscussionAPI.removeDiscussionFromLibrary(ctx, user.id, element.id, function(err) {
                        finish ++;
                        // When no more discussions, return callback
                        if (discussions.length === finish) { 
                            return callback(null);                    
                        }
                    });
                }
            });
        });   
    });
};

/**
 * Delete rights on discussions + update roles on editors && on user archive
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            The user to delete
 * @param  {String}     archiveUser     User Archive
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _transferRightMeetings = function(ctx, user, archiveUser, callback) {

    // Get all documents 
    MeetingAPI.getMeetingsLibrary(ctx, user.id, null, null, function(err, meetings) {

        if(err) {
            return callback(err);
        }
        if(_.isEmpty(meetings)) {
            return callback();
        }
        var contentIds = [];
        var finish = 0;
        meetings.forEach(function(element, id, arr) {

            // If he's not a manager, do nothing
            AuthzAPI.hasRole(user.id, element.id, AuthzConstants.role.MANAGER, function(err, hasRole) {
                if(err) {
                    return callback(err);
                }

                if(hasRole) {

                    // Search if other user have right on this document
                    MeetingAPI.getMeetingMembers(ctx, element.id, null, null, function(err, memberList) {
                        if(err) {
                            return callback(err);
                        }

                        // Remove the deleted user from the member list
                        _deleteManagerArray(memberList, user.id, function(err, newMemberList) {
                            if(err) {
                                return callback(err);
                            }

                            // If member list is empty - return
                            if(_.isEmpty(newMemberList)) { 
                                _addToArchive(archiveUser.idArchive, user.id, element.id, function(err) {
                                    if(err) {
                                        return callback(err);
                                    }
                                }); 

                                var update = {}; 
                                update[archiveUser.idArchive] = AuthzConstants.role.MANAGER;
                                _setMeetingMembersNoVerif(ctx, element, update, function(err) {
                                    if(err) {
                                        return callback(err);
                                    }

                                    // Delete all his right and remove from library
                                    MeetingAPI.removeMeetingFromLibrary(ctx, user.id, element.id, function(err) {
                                        finish ++;
                                        // When no more meetings, return callback
                                        if (meetings.length === finish) { 
                                            return callback(null);                    
                                        }
                                    });
                                });
                            } else {

                                // Promote the user to the manager role
                                _promoteRoles(newMemberList, element, function(err) {
                                    if(err) {
                                        return callback(err);
                                    }

                                    // Delete all his right and remove from library
                                    MeetingAPI.removeMeetingFromLibrary(ctx, user.id, element.id, function(err) {
                                        finish ++;
                                        // When no more meetings, return callback
                                        if (meetings.length === finish) { 
                                            return callback(null);                    
                                        }
                                    });
                                });
                            }
                        });
                    });
                } else {
                    // Delete all his right and remove from library
                    MeetingAPI.removeMeetingFromLibrary(ctx, user.id, element.id, function(err) {
                        finish ++;
                        // When no more meetings, return callback
                        if (meetings.length === finish) { 
                            return callback(null);                    
                        }
                    });
                }
            });
        });   
    });
};

var _setMeetingMembersNoVerif = function(ctx, meeting, changes, callback) {

    ResourceActions.setRoles(ctx, meeting, changes, true, function (err, memberChangeInfo) {
        if (err) {
            return callback(err);
        }

        MeetingsAPI.emit(MeetingsConstants.events.UPDATED_MEETING_MEMBERS, ctx, meeting, memberChangeInfo, {}, function (errs) {
            if (errs) {
                return callback(_.first(errs));
            }

            return callback();
        });
    });
};

/**
 * Delete rights on groups + update roles on editors && on user archive
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            The user to delete
 * @param  {String}     archiveUser     User Archive
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _transferRightGroup = function(ctx, user, archiveUser, callback) {

    // Get all documents 
    GroupAPI.getMembershipsLibrary(ctx, user.id, null, null, function(err, groups) {
        if(err) {
            return callback(err);
        }
        if(_.isEmpty(groups)) {
            return callback();
        }
        var contentIds = [];
        var finish = 0;
        groups.forEach(function(element, id, arr) {

            // If he's not a manager, do nothing
            AuthzAPI.hasRole(user.id, element.id, AuthzConstants.role.MANAGER, function(err, hasRole) {
                if(err) {
                    return callback(err);
                } 

                if(hasRole) {

                    // Search if other user have right on this document
                    GroupAPI.getMembersLibrary(ctx, element.id, null, null, function(err, memberList) {
                        if(err) {
                            return callback(err);
                        }

                        // Remove the deleted user from the member list
                        _deleteManagerArray(memberList, user.id, function(err, newMemberList) {
                            if(err) {
                                return callback(err);
                            }

                            _deleteManagerArray(memberList, user.id, function(err, newMemberList) {
                                if(err) {
                                    return callback(err);
                                }

                                // If there is no manager/member/editor delete it, else do nothing 
                                if(_.isEmpty(newMemberList)) { 

                                    _addToArchive(archiveUser.idArchive, user.id, element.id, function(err) {
                                        if(err) {
                                            return callback(err);
                                        }
                                        // Remove the right of deleted user
                                        var update = {}; 
                                        update[user.id] = false;
                                        AuthzAPI.updateRoles(element.id, update, function(err) {
                                            finish ++;
                                            // When no more groups, return callback
                                            if (groups.length === finish) { 
                                                return callback(null);                    
                                            }
                                        });
                                    });  

                                    var update = {}; 
                                    update[archiveUser.idArchive] = AuthzConstants.role.MANAGER;

                                    _setGroupMembersNoVerif(ctx, element, update, function(err) {
                                        if(err) {
                                            return callback(err);
                                        }

                                        // Remove the right of deleted user
                                        var update = {}; 
                                        update[user.id] = false;
                                        AuthzAPI.updateRoles(element.id, update, function(err) {
                                            finish ++;
                                            // When no more groups, return callback
                                            if (groups.length === finish) { 
                                                return callback(null);                    
                                            }
                                        });
                                    });  
                                } else {

                                    // Promote the user to the manager role
                                    _promoteRoles(newMemberList, element, function(err) {
                                        if(err) {
                                            return callback(err);
                                        }

                                        // Remove the right of deleted user
                                        var update = {}; 
                                        update[user.id] = false;
                                        AuthzAPI.updateRoles(element.id, update, function(err) {
                                            finish ++;
                                            // When no more groups, return callback
                                            if (groups.length === finish) { 
                                                return callback(null);                    
                                            }
                                        });
                                    });
                                }
                                
                            });
                        });
                    });
                } else {
                    var update = {}; 
                    update[user.id] = false;
                    AuthzAPI.updateRoles(element.id, update, function(err) {
                        finish ++;
                        // When no more groups, return callback
                        if (groups.length === finish) { 
                            return callback(null);                    
                        }
                    });
                }
            });
        });   
    });
};

var _setGroupMembersNoVerif = function(ctx, group, changes, callback) {

    ResourceActions.setRoles(ctx, group, changes, true, function(err, memberChangeInfo) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(memberChangeInfo.changes)) {
            return callback();
        }

        PrincipalsUtil.touchLastModified(group, function(err, updatedGroup) {
            if (err) {
                return callback(err);
            }

            PrincipalsEmitter.emit(PrincipalsConstants.events.UPDATED_GROUP_MEMBERS, ctx, updatedGroup, group, memberChangeInfo, {}, function(errs) {
                if (errs) {
                    return callback(_.first(errs));
                }

                return callback();
            });
        });
    });
};

/**
 * TODO : Find an alternative, the groupe are no removed from the library /!\
 *
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _deleteManagerArray = function(memberList, userId, callback) {
    
    var nb = 0;
    var newMemberList = [];

    memberList.forEach(function(element) {

        nb++;

        if(element.profile.id !== userId) {
            newMemberList.push(element);
        }

        if (memberList.length === nb) { 
            return callback(null, newMemberList);                    
        }

    });
};

/**
 * Remove all followers
 *
 * @param  {String}     user            The user to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _deleteFollowers = function(user, callback) {

    // Remove following users
    FollowingDAO.getFollowing(user.id, null, null, function(err, userIds) {
        FollowingDAO.deleteFollows(user.id, userIds, function(err) {
            if(err) {
                return callback(err);
            }
            return callback(null);
        });
    });

    // Remove followers
    FollowingDAO.getFollowers(user.id, null, null, function(err, userIds) {
        userIds.forEach(function(id) {
            FollowingDAO.deleteFollows(id, user.id, function(err) {
                if(err) {
                    return callback(err);
                }
                return callback(null);
            });
        });
    });
};

/**
 * Add elements to archive
 *
 * @param  {String}     userArchiveId   The user archive of the tenant
 * @param  {String}     principalId     The id user to delete 
 * @param  {String}     elementId       The id element to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _addToArchive = function(userArchiveId, principalId, elementId, callback) {

    if(!userArchiveId) {
        return callback(null);
    }

    if(!principalId) {
        return callback(null);
    }

    if(!elementId) {
        return callback(null);
    }

    // Add the element to data archive
    PrincipalsDAO.addDataInArchive(userArchiveId, principalId, [elementId], function(err) {
        if(err) {
            return callback(err);
        }
        return callback(null);  
    });  
};

/**
 * Promote role -> member to manager
 *
 * @param  {ArrObject}  memberList      List of members
 * @param  {Object}     element         The resource 
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _promoteRoles = function(memberList, element, callback) {
    var type = element.id.split(':')[0];
    var elementId = element.id; 

    if(type === 'f') {
        elementId = element.groupId;
    }

    var hasManager = false;
    var members = [];

    // If there is some members, look at his rights
    memberList.forEach(function(person, idx, array) {

        // If he's manager, return and set hasManager to true
        if(person.role === AuthzConstants.role.MANAGER) { 
            hasManager = true;
        } else {
            members.push(person.profile.id)
        } 

        // If it's the last iteration and we don't find any manager, promote all editor -> manager
        if (idx === array.length - 1) {

            if(!hasManager) {
                var update = {};

                members.forEach(function(member, idMember, arrayMember) {
                    update[member] = AuthzConstants.role.MANAGER;

                    // When no more editor, do update
                    if (idMember === arrayMember.length - 1) { 
                        AuthzAPI.updateRoles(elementId, update, function(err, usersToInvalidate) {
                            if(err) {
                                return callback(err);
                            }
                            return callback(null);                    
                        });
                    }
                });
            } else {
                return callback(null);
            }
        }
    });
};




/** =============================================================== **/
/** ===================== Definitive deletion ===================== **/
/** =============================================================== **/

/**
 * Definitive delete of user
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            User that will be deleted
 * @param  {String}     alias           Tenant alias
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 */
var definitiveDeletion = module.exports.definitiveDeletion = function(ctx, user, alias, callback) {
    callback = callback || function() {};

    // Get userArchive
    PrincipalsDAO.getUserArchive(alias, function(err, userArchive) {
        if (err) {
            return callback(err);
        }   
        // Delete all rights on resources
        _deleteRightResources(ctx, user, userArchive.idArchive, function(err) {
            if (err) {

                return callback(err);
            } 

            // Mark the user as deleted and then, deleted him
            PrincipalsDAO.deletePrincipal2(ctx, user, function(err) {
                if (err) {
                    return callback(err);
                }

                // Notify consumers that a user has been deleted
                log().info({'userId': user.id, 'name': 'oae-principals'}, 'Definitive deletion user with a mapped login id');

                // Notify that a user has been deleted
                PrincipalsEmitter.emit(PrincipalsConstants.events.DELETED_USER, ctx, user, function(err) {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, true);
                });
            });
        });
    });
};

/**
 * Remove all his rights on resources
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     user            The user to delete
 * @param  {String}     idArchive       The user archive of the tenant
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _deleteRightResources = function(ctx, user, idArchive, callback) {

    // Get all data from user archive where data belonged to the user removed
    PrincipalsDAO.getDataFromArchive(idArchive, user.id, function(err, ids) {
        if(err) {
            return callback(err);
        } 
        if(_.isEmpty(ids)) {
            return callback();
        }

        // Remove the data from the table "DataArchive"
        PrincipalsDAO.removeDataInArchive(idArchive, user.id, function(err) {
            if(err) {
                return callback(err);
            }
            var finish = 0;

            ids.forEach(function(id) {

                // if the data belonged to the removed user, delete the resource
                if(id.principalId == user.id) {
                    
                    // Get type of resource
                    var idResource = id.idResources;
                    var idSplite = idResource.split(':');

                    // If it's a folder get the idGroup
                    _ifFolderGetIdGroup(ctx, idResource, idSplite[0], function(err, idFolder) {
                        if(err) {
                            return callback(err);
                        }
                        if(idFolder) {
                            idResource = idFolder;
                        }
                        
                        // Get role
                        AuthzAPI.getAllAuthzMembers(idResource, function(err, memberIdRoles) {

                            var managers = 0;
                            var rolesMember = _.pluck(memberIdRoles, 'role');

                            _.each(rolesMember, function(role) {
                                if(role == 'manager') {
                                    managers = managers + 1;
                                }
                            });
                            var del = true;

                            // If there is more than 1 manager, keep of the manager role to user archive
                            if(managers > 1) {
                                del = false;

                            // Else if the user archive is the only one manager, delete the resource
                            } else {
                                del = true;
                            }

                            // Remove the resource with the appropriate method
                            if(idSplite[0] == "c") {
                                _deleteRightContent(ctx, del, idArchive, idResource, function(err) {
                                    if(err) {
                                        return callback(err);
                                    } else {
                                        finish ++;
                                        if (finish === ids.length) { 
                                            return callback(); 
                                        }
                                    }
                                });
                            } else if(idSplite[0] == "d") {
                                _deleteRightDiscussion(ctx, del, idArchive, idResource, function(err) {
                                    if(err) {
                                        return callback(err);
                                    } else {
                                        finish ++;
                                        if (finish === ids.length) { 
                                            return callback(); 
                                        }
                                    }
                                });
                            } else if(idSplite[0] == "f") {
                                _deleteRightFolder(ctx, del, idArchive, id.idResources, function(err) {
                                    if(err) {
                                        return callback(err);
                                    } else {
                                        finish ++;
                                        if (finish === ids.length) { 
                                            return callback(); 
                                        }
                                    }
                                });
                            } else if(idSplite[0] == "g") {
                                _deleteRightGroup(ctx, del, idArchive, idResource, function(err) {
                                    if(err) {
                                        return callback(err);
                                    } else {
                                        finish ++;
                                        if (finish === ids.length) { 
                                            return callback(); 
                                        }
                                    }
                                });
                            } else if(idSplite[0] == "m") {
                                _deleteRightMeeting(ctx, del, idArchive, idResource, function(err) {
                                    if(err) {
                                        return callback(err);
                                    } else {
                                        finish ++;
                                        if (finish === ids.length) { 
                                            return callback(); 
                                        }
                                    }
                                });
                            }
                        });
                    });
                }
                finish ++;

                // If last element, return callback
                if (finish === ids.length) { 
                    return callback(); 
                }
            });
        });
    });
};

/**
 * Remove right on content or remove it if there is no manager 
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     idResource      The id of the resource to delete
 * @param  {String}     idSplite        The first part of a resource id (e.g. f:test:ryfQL_D4b, it will be "f") who define the type of resource
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _ifFolderGetIdGroup = function(ctx, idResource, idSplite, callback) {
    if(idSplite == "f") {
        FolderAPI.getFolder(ctx, idResource, function(err, folder) { 
            if(err) {
                return callback(err);
            }
            return callback(null, folder.groupId);
        });
    } else {
        return callback(null)
    }
};

/**
 * Remove right on content or remove it if there is no manager 
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Boolean}    del             The variable who determine if the element should be remove or not
 * @param  {String}     idArchive       The id user archive of the tenant
 * @param  {String}     idResource      The id of the resource to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _deleteRightContent = function(ctx, del, idArchive, idResource, callback) {
    if(del) {

        // Remove content
        ContentAPI.deleteContent(ctx, idResource, function(err) {
            if(err) {
                return callback(err);
            }
            return callback();
        });
    } else {

        // If there is another manager on the content, remove it from the library
        ContentAPI.removeContentFromLibrary(ctx, idArchive, idResource, function(err) {
            if(err) {
                return callback(err);
            }
            return callback();
        });
    }
};

/**
 * Remove right on discussion or remove it if there is no manager 
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Boolean}    del             The variable who determine if the element should be remove or not
 * @param  {String}     idArchive       The id user archive of the tenant
 * @param  {String}     idResource      The id of the resource to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _deleteRightDiscussion = function(ctx, del, idArchive, idResource, callback) {
    if(del) {

        // Remove the actual discussion profile
        // TODO : find a solution to use the API method
        DiscussionAPI.deleteDiscussion(ctx, idResource, function(err) {
            if (err) {
                return callback(err);
            }
            return callback();
        });
    } else {
        
        // If there is another manager on the discussion, remove it from the library
        DiscussionAPI.removeDiscussionFromLibrary(ctx, idArchive, idResource, function(err) {
            if (err) {
                return callback(err);
            }
            return callback();
        });        
    }
};

/**
 * Remove right on folder or remove it if there is no manager 
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Boolean}    del             The variable who determine if the element should be remove or not
 * @param  {String}     idArchive       The id user archive of the tenant
 * @param  {String}     idResource      The id of the resource to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _deleteRightFolder = function(ctx, del, idArchive, idResource, callback) {
    if(del) {

        // Remove folder
        FolderAPI.deleteFolder(ctx, idResource, false, function(err, content) {
            if(err) {
                return callback(err);
            }
            return callback();
        });
    } else {

        // If there is another manager on the folder, remove it from the library
        FolderAPI.removeFolderFromLibrary(ctx, idArchive, idResource, function(err) {
            if(err) {
                return callback(err);
            }
            return callback();
        });
    }
};

/**
 * Remove right on group or remove it if there is no manager 
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Boolean}    del             The variable who determine if the element should be remove or not
 * @param  {String}     idArchive       The id user archive of the tenant
 * @param  {String}     idResource      The id of the resource to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _deleteRightGroup = function(ctx, del, idArchive, idResource, callback) {
    if(del) {

        // Remove group
        GroupAPI.deleteGroup(ctx, idResource, function(err) {
            if(err) {
                return callback(err);
            }

            // Remove roles
            var update = {};
            update[idArchive] = false;
            AuthzAPI.updateRoles(idResource, update, function(err, usersToInvalidate) {
                if(err) {
                    return callback(err);
                }
                return callback();                    
            });
        });
    } else {

        // If there is another manager on the group, remove it from the library
        // TODO : take the id of the context, maybe modify the leaveGroup function
        GroupAPI.leaveGroup(ctx, idResource, function(err) {
            if(err) {
                return callback(err);
            }
            return callback();
        });
    }
};

/**
 * Remove right on meeting or remove it if there is no manager 
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Boolean}    del             The variable who determine if the element should be remove or not
 * @param  {String}     idArchive       The id user archive of the tenant
 * @param  {String}     idResource      The id of the resource to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occured, if any
 * @api private
 */
var _deleteRightMeeting = function(ctx, del, idArchive, idResource, callback) {
    if(del) {

        // Remove meeting
        MeetingAPI.deleteMeeting(ctx, idResource, function(err) {
            if(err) {
                return callback(err);
            }
            return callback();
        });
    } else {

        // If there is another manager on the meeting, remove it from the library
        MeetingAPI.removeMeetingFromLibrary(ctx, idArchive, idResource, function(err) {
            if(err) {
                return callback(err);
            }
            return callback();
        });
    }
};
