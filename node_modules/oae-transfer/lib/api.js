/*!
 * Copyright 2017 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');
var Validator = require('oae-util/lib/validator').Validator;

var EmailAPI = require('oae-email/lib/api');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var TenantsUtil = require('oae-tenants/lib/util');

var TransferDAO = require('./internal/dao');

/**
 * PUBLIC FUNCTIONS
 */

/**
 * Create a new transfer.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     emailOrigin     Email origin
 * @param  {String}     emailTarget     Email target
 * @param  {String}     idUserOrigin    The id of the user who create the transfer         
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api private
 */
var createTransfer = module.exports.createTransfer = function (ctx, idUserOrigin, emailOrigin, emailTarget, callback) {
    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot create a transfer'}).isLoggedInUser(ctx);
    validator.check(emailTarget, {'code': 400, 'msg': 'EmailTarget cannot be empty'}).notEmpty();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    TransferDAO.createTransfer(ctx, idUserOrigin, emailOrigin, emailTarget, function(err, transfer) {
        if(err) {
            return callback(err);
        }
        return callback(null, transfer);
    });
};

/**
 * Get a transfer by id.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {string}     idUserOrigin    The id of the user who created the transfer               
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api private
 */
var getTransferById = module.exports.getTransferById = function (ctx, idUserOrigin, callback) {
    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();
    validator.check(idUserOrigin, {'code': 400, 'msg': 'Id cannot be empty'}).notEmpty();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    TransferDAO.getTransferById(idUserOrigin, function(err, transfer) {
        if (err) {
            return callback(err);
        }
        return callback(null, transfer);
    });
};

/**
 * Start the transfer.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     emailOrigin     Email origin
 * @param  {String}     code            Transfer code
 * @param  {String}     emailTarget     Email target
 * @param  {String}     idUserTarget    Id user target
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api private
 */
var makeTransfer = module.exports.makeTransfer = function (ctx, emailOrigin, code, emailTarget, idUserTarget, callback) {
    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();
    validator.check(emailOrigin, {'code': 400, 'msg': 'Email cannot be empty'}).notEmpty();    
    validator.check(code, {'code': 400, 'msg': 'Code cannot be empty'}).notEmpty();
    validator.check(emailOrigin, {'code': 400, 'msg': 'Invalid email'}).isEmail();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    
    TransferDAO.makeTransfer(ctx, emailOrigin, code, emailTarget, idUserTarget, function(err, managers, updatedEditors) {
        if(err) {
            return callback(err);
        } else {
            // If there is no error, send emails to manager to advice them
            _sendEmail(ctx, managers, emailOrigin, emailTarget, function(err) {
                if(err) {
                    return callback(err);
                }
            });
        }
        return callback(null, managers);
    });
};

/**
 * Delete the transfer.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     emailOrigin     The email of the user who create the transfer          
 * @param  {String}     code            The transfer code
 * @param  {string}     idUserOrigin    The id of the user who created the transfer               
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api privat
 */
var deleteTransfer = module.exports.deleteTransfer = function (ctx, emailOrigin, code, idUserOrigin, callback) {
    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();

    validator.check(emailOrigin, {'code': 400, 'msg': 'Email cannot be empty'}).notEmpty();
    validator.check(code, {'code': 400, 'msg': 'Code cannot be empty'}).notEmpty();
    validator.check(idUserOrigin, {'code': 400, 'msg': 'Id cannot be empty'}).notEmpty();
    validator.check(emailOrigin, {'code': 400, 'msg': 'Invalid email'}).isEmail();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    TransferDAO.deleteTransfer(emailOrigin, code, idUserOrigin, function(err) {
        if(err) {
            return callback(err);
        } 
        return callback(null);
    });
};


/**
 * Send an email token to a user that can be used to notify the user transfer
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Manager}    managers        The managers
 * @param  {String}     oldUserMail     OldUser email
 * @param  {String}     newUserMail     NewUser email
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api private
 */
_sendEmail = function(ctx, managers, oldUserMail, newUserMail, callback) {
    // Generate a token if none was specified
    var token = ShortId.generate();
    managers.map(function(hash) {
        // if the user target is a manager, don't send email
        if(hash.email !== newUserMail) {
        	// Store the token
    	    PrincipalsDAO.storeEmailToken(ctx.user().id, hash.email, token, function(err) {
    	        if (err) {
    	            return callback(err);
    	        }
    	        var userToEmail = _.extend({}, hash, {'email': hash.email, 'id': hash.principalId,'tenant':{'alias': hash.tenantAlias}});
    	        // Send an email to the specified e-mail address
    	        var data = {
                    'actor': ctx.user(),
    	            'TransferingAccount': ctx.user(),
    	            'tenant': ctx.tenant().displayName,
    	            'user': userToEmail,
    	            'baseUrl': TenantsUtil.getBaseUrl(ctx.tenant()),
    	            'skinVariables': require('oae-ui').getTenantSkinVariables(ctx.tenant().alias),
    	            'token': token,
                    'nameResource': hash.resource,
                    'oldUserMail': oldUserMail,
                    'newUserMail': newUserMail
    	        };
    	        EmailAPI.sendEmail('oae-transfer', 'notify', userToEmail, data, {'hash': Date.now()});
                //console.log("email sent to : " + hash.displayName + " - " + hash.email + ", for the resource : " + hash.resource);
    	        return callback(null);
    	    });
        }
    });
};
