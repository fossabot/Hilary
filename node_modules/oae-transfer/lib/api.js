/*!
 * Copyright 2017 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');
var Validator = require('oae-util/lib/validator').Validator;

var EmailAPI = require('oae-email/lib/api');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var TenantsUtil = require('oae-tenants/lib/util');

var TransferDAO = require('./internal/dao');

/**
 * PUBLIC FUNCTIONS
 */

/**
 * Create a new transfer.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     emailOrigin     Email origin
 * @param  {String}     emailTarget     Email target
 * @param  {String}     idUserOrigin    The id of the user who create the transfer         
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api private
 */
var createTransfer = module.exports.createTransfer = function (ctx, idUserOrigin, emailOrigin, emailTarget, callback) {
    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot create a transfer'}).isLoggedInUser(ctx);
    validator.check(emailTarget, {'code': 400, 'msg': 'EmailTarget cannot be empty'}).notEmpty();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    TransferDAO.createTransfer(ctx, idUserOrigin, emailOrigin, emailTarget, function(err, transfer) {
        if(err) {
            return callback(err);
        }
        return callback(null, transfer);
    });
};

/**
 * Get a transfer by id.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {string}     idUserOrigin    The id of the user who created the transfer               
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api private
 */
var getTransferById = module.exports.getTransferById = function (ctx, idUserOrigin, callback) {
    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();
    validator.check(idUserOrigin, {'code': 400, 'msg': 'Id cannot be empty'}).notEmpty();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    TransferDAO.getTransferById(idUserOrigin, function(err, transfer) {
        if (err) {
            return callback(err);
        }
        return callback(null, transfer);
    });
};

/**
 * Start the transfer.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     emailOrigin     Email origin
 * @param  {String}     code            Transfer code
 * @param  {String}     emailTarget     Email target
 * @param  {String}     idUserTarget    Id user target
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api private
 */
var makeTransfer = module.exports.makeTransfer = function (ctx, emailOrigin, code, emailTarget, idUserTarget, callback) {
    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();
    validator.check(emailOrigin, {'code': 400, 'msg': 'Email cannot be empty'}).notEmpty();    
    validator.check(code, {'code': 400, 'msg': 'Code cannot be empty'}).notEmpty();
    validator.check(emailOrigin, {'code': 400, 'msg': 'Invalid email'}).isEmail();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    
    TransferDAO.makeTransfer(ctx, emailOrigin, code, emailTarget, idUserTarget, function(err, managers, updatedEditors) {
        if(err) {
            return callback(err);
        } else if(_.isEmpty(managers) && _.isEmpty(updatedEditors)) {Â 
            return callback(null);
        } else {

            // If there is no error, send emails to manager to advice them
            _sendEmail(ctx, managers, updatedEditors, idUserTarget, emailOrigin, emailTarget, function(err, parsedData) {
                if(err) {
                    return callback(err);
                }
                return callback(null, parsedData);
            });
        }
    });
};

/**
 * Delete the transfer.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     emailOrigin     The email of the user who create the transfer          
 * @param  {String}     code            The transfer code
 * @param  {string}     idUserOrigin    The id of the user who created the transfer               
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api privat
 */
var deleteTransfer = module.exports.deleteTransfer = function (ctx, emailOrigin, code, idUserOrigin, callback) {
    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();

    validator.check(emailOrigin, {'code': 400, 'msg': 'Email cannot be empty'}).notEmpty();
    validator.check(code, {'code': 400, 'msg': 'Code cannot be empty'}).notEmpty();
    validator.check(idUserOrigin, {'code': 400, 'msg': 'Id cannot be empty'}).notEmpty();
    validator.check(emailOrigin, {'code': 400, 'msg': 'Invalid email'}).isEmail();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    TransferDAO.deleteTransfer(emailOrigin, code, idUserOrigin, function(err) {
        if(err) {
            return callback(err);
        } 
        return callback(null);
    });
};


/**
 * Send an email token to a user that can be used to notify the user transfer
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Manager}    managers        The managers
 * @param  {String}     oldUserMail     OldUser email
 * @param  {String}     newUserMail     NewUser email
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api private
 */
var _sendEmail = function(ctx, managers, updatedEditors, idUserTarget, oldUserMail, newUserMail, callback) {

    // ParseData from variable informations to make an union on user. Start with managers
    _parseData(managers, 'notifyManagers', idUserTarget, [], function(err, parseDataManager) {
        if (err) {
            return callback(err);
        }

        // Make another loop for updated editors     
        _parseData(updatedEditors, 'notifyNewManagers', idUserTarget, parseDataManager, function(err, parseDataNewManager) {
            if (err) {
                return callback(err);
            }
            // TODO
            if(_.isEmpty(parseDataNewManager.users[0].notifyManagers) && _.isEmpty(parseDataNewManager.users[0].notifyNewManagers)) {
                parseDataNewManager.users.shift();
            }
            if(_.isEmpty(parseDataNewManager.users)) {
                return callback(null);
            } 

            // TODO make test
            parseDataNewManager.users.forEach(function(hash, i, arrI) {

                // if the user target is a manager, don't send email
                if(hash.email !== newUserMail) {
                    
                    // Generate a token
                    var token = ShortId.generate();

                	// Store the token
            	    PrincipalsDAO.storeEmailToken(ctx.user().id, hash.email, token, function(err) {
            	        if (err) {
            	            return callback(err);
            	        }

            	        var userToEmail = _.extend({}, hash, {'email': hash.email, 'id': hash.principalId,'tenant':{'alias': hash.tenantAlias}});
            	        
                        // Send an email to the specified e-mail address
            	        var data = {
                            'actor': ctx.user(),
            	            'TransferingAccount': ctx.user(),
            	            'tenant': ctx.tenant().displayName,
            	            'user': userToEmail,
            	            'baseUrl': TenantsUtil.getBaseUrl(ctx.tenant()),
            	            'skinVariables': require('oae-ui').getTenantSkinVariables(ctx.tenant().alias),
            	            'token': token,
                            'oldUserMail': oldUserMail,
                            'newUserMail': newUserMail,
                            'resourceManager': hash.notifyManagers,
                            'resourceNewManager': hash.notifyNewManagers,
            	        };

            	        EmailAPI.sendEmail('oae-transfer', 'notify', userToEmail, data, {'hash': Date.now()});
                        // console.log("email sent to : " + hash.displayName + " - " + hash.email + ", for the resource : " + hash.resource);
            	        
                        if(arrI.length-1 === i) {
                            return callback(null, parseDataNewManager);
                        }
            	    });
                }
            });
        });
    });
};

/**
 * Send an email token to a user that have a resource shared with the deleted user
 *
 * @param  {Object}     members         List of the user to send the email token to with the resource concerned
 * @param  {String}     typeOfMember    Type of member : manager or editors updated
 * @param  {String}     idUserTarget    Id of the target user
 * @param  {Object}     list            List of parsed data
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var _parseData = function(members, typeOfMember, idUserTarget, list, callback) {
    if(_.isEmpty(members)) {
        return callback(null, list);
    }

    var exist = false;
    var listElementByMember = list;

    // For each manager of a resource
    members.forEach(function(member, i, arrI) {

        if(_.isEmpty(listElementByMember)) {
            listElementByMember = {'users': [] };
            listElementByMember.users.push({'notifyManagers': [], 'notifyNewManagers': [], 'profile': member});
        }

        // Create another list to sort by user the list of resource
        listElementByMember.users.forEach(function(element, j, arrJ) {
            if (member.principalId !== idUserTarget) {

                // Add resource to user 
                if ((element.profile.principalId === member.principalId)) {
                    exist=true;
                    if(typeOfMember === "notifyManagers") {
                        element.notifyManagers.push(member.resource);
                    } else if(typeOfMember === "notifyNewManagers") {
                        element.notifyNewManagers.push(member.resource);
                    }
                }

                // If user do not exist in the list, create it
                if ((j === arrJ.length-1) && (exist === false)) {
                    listElementByMember.users.push({'notifyManagers': [], 'notifyNewManagers': [], 'profile': member});
                    if(typeOfMember === "notifyManagers") {
                        listElementByMember.users[j+1].notifyManagers.push(member.resource);
                    } else if(typeOfMember === "notifyNewManagers") {
                        listElementByMember.users[j+1].notifyNewManagers.push(member.resource);
                    }
                }
            }
        });
        // If last element, return
        if (i === arrI.length-1) { 
            return callback(null, listElementByMember);
        }
    });
};
