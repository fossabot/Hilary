/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');

var Validator = require('oae-util/lib/validator').Validator;
var TenantsUtil = require('oae-tenants/lib/util');

var EmailAPI = require('oae-email/lib/api');

var TransferDAO = require('./internal/dao');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');

/**
 * PUBLIC FUNCTIONS
 */

/**
 * Create a new transfer.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     emailOrigin     Email origin
 * @param  {String}     emailTarget     Email target
 * @param  {String}     idUserTarget    Id user target
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api private
 */
var createTransfer = module.exports.createTransfer = function (ctx, emailOrigin, emailTarget, idUserOrigin, callback) {
    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Anonymous users cannot create a meeting'}).isLoggedInUser(ctx);
    validator.check(emailTarget, {'code': 400, 'msg': 'emailTarget cannot be empty'}).notEmpty();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    TransferDAO.createTransfer(ctx, emailOrigin, emailTarget, idUserOrigin, function(err, transfer){
        if(err){
            return callback(err);
        }
        return callback(null, transfer);
    });
};

/**
 * Get a transfer by email.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     email           Email 
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api private
 */
var getTransferByEmail = module.exports.getTransferByEmail = function (ctx, email, callback) {
    callback = callback || function() {};

    // Verify basic properties
    var validator = new Validator();
    validator.check(email, {'code': 400, 'msg': 'email cannot be empty'}).notEmpty();
    validator.check(email, {'code': 400, 'msg': 'invalid email'}).isEmail();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    TransferDAO.getTransferByEmail(email, function(err, transfer) {
        if (err) {
            return callback(err);
        }
		return callback(null, transfer);
    });
};

/**
 * Start the transfer.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     emailOrigin     Email origin
 * @param  {String}     code            OldUser email
 * @param  {String}     emailTarget     Email target
 * @param  {String}     idUserTarget    Id user target
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api private
 */
var makeTransfer = module.exports.makeTransfer = function (ctx, emailOrigin, code, emailTarget, idUserTarget, callback) {
    callback = callback || function() {};
    // Verify basic properties
    var validator = new Validator();
    validator.check(emailOrigin, {'code': 400, 'msg': 'email cannot be empty'}).notEmpty();    
    validator.check(code, {'code': 401, 'msg': 'code cannot be empty'}).notEmpty();
    validator.check(emailOrigin, {'code': 402, 'msg': 'invalid email'}).isEmail();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    
    TransferDAO.makeTransfer(ctx, emailOrigin, code, emailTarget, idUserTarget, function(err, managers){
        if(err){
            return callback(err);
        } else {
            // If there is no error, send emails to manager to advice them
            _sendEmail(ctx, managers, emailOrigin, emailTarget, function(err){
                if(err){
                    return callback(err);
                }
            });
        }
        return callback(null, managers);
    });
};

/**
 * Delete the transfer.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}      emailOrigin     Email origin
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api privat
 */
var deleteTransfer = module.exports.deleteTransfer = function (ctx, emailOrigin, callback) {
    callback = callback || function() {};
    // Verify basic properties
    var validator = new Validator();

    validator.check(emailOrigin, {'code': 400, 'msg': 'email cannot be empty'}).notEmpty();
    validator.check(emailOrigin, {'code': 400, 'msg': 'invalid email'}).isEmail();

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    TransferDAO.deleteTransfer(emailOrigin, function(err){
        if(err){
            return callback(err);
        } 
        return callback(null);
    });
};


/**
 * Send an email token to a user that can be used to notify the user transfer
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {Manager}    managers        The managers
 * @param  {String}     oldUserMail     OldUser email
 * @param  {String}     newUserMail     NewUser email
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred
 * @api private
 */
_sendEmail = function(ctx, managers, oldUserMail, newUserMail, callback) {
    // Generate a token if none was specified
    var token = ShortId.generate();
    managers.map(function(hash){
        // if the user target is a manager, don't send email
        if(hash.email !== newUserMail){
        	// Store the token
    	    PrincipalsDAO.storeEmailToken(ctx.user().id, hash.email, token, function(err) {
    	        if (err) {
    	            return callback(err);
    	        }
    	        // The EmailAPI expects a user to have a verified email address. As this is not the case
    	        // when sending an email token, we send in a patched user object
    	        var userToEmail = _.extend({}, hash, {'email': hash.email, 'id': hash.principalId,'tenant':{'alias': hash.tenantAlias}});
    	        // Send an email to the specified e-mail address
    	        var data = {
                    'actor': ctx.user(),
    	            'TransferingAccount': ctx.user(),
    	            'tenant': ctx.tenant().displayName,
    	            'user': userToEmail,
    	            'baseUrl': TenantsUtil.getBaseUrl(ctx.tenant()),
    	            'skinVariables': require('oae-ui').getTenantSkinVariables(ctx.tenant().alias),
    	            'token': token,
                    'nameResource': hash.resource,
                    'oldUserMail': oldUserMail,
                    'newUserMail': newUserMail
    	        };
    	        // We pass the current date in as the "hashCode" for this email. We need to be able to send
    	        // a copy of the same email for the "resend email token" functionality. As we don't expect
    	        // that this logic will get stuck in a loop this is probably OK
    	        EmailAPI.sendEmail('oae-transfer', 'notify', userToEmail, data, {'hash': Date.now()});
                console.log("email sent to : " + hash.displayName + " - " + hash.email + ", for the resource : " + hash.resource);
    	        return callback(null);
    	    });
        }
    });
};
