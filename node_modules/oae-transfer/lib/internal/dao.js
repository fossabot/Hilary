/*!
 * Copyright 2017 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');
var util = require('util');
var Cassandra = require('oae-util/lib/cassandra');
var CodeGenerator = require('password-generator');
var Async = require('async');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var ContentConstants = require('oae-content/lib/constants').ContentConstants;
var ContentDAO = require('oae-content/lib/internal/dao.content');
var DiscussionsConstants = require('oae-discussions/lib/constants').DiscussionsConstants;
var DiscussionsDAO = require('oae-discussions/lib/internal/dao');
var FoldersConstants = require('oae-folders/lib/constants').FoldersConstants;
var FoldersDAO = require('oae-folders/lib/internal/dao');
var GroupAPI = require('oae-principals/lib/api.group');
var LibraryAPI = require('oae-library'); 
var PrincipalsAPI = require('oae-principals/lib/api.user');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');

var TransferByEmail = require('oae-transfer/lib/model').TransferByEmail;


/** 
 * PUBLIC FUNCTIONS 
 */

/**
 * Create a new transfer.
 *
 * @param  {String}         emailOrigin             Email origin
 * @param  {String}         emailTarget             Email target
 * @param  {String}         idUserOrigin            Id user origin
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {transfer}       callback.transfer       The transfer that was created
 */
var createTransfer = module.exports.createTransfer = function (ctx, idUserOrigin, emailOrigin, emailTarget, callback) {    
    var code = _createTransferCode();
    var finalLifetime = 0;
    _getLifeTimeTransfer(ctx, function (err, lifetime) {
        if (err) {
            return callback(err);
        }
        finalLifetime = lifetime * 86400;

        Cassandra.runQuery('INSERT INTO "TransferById" ("idUserOrigin", "code", "emailOrigin", "emailTarget") VALUES (?, ?, ?, ?) USING TTL ?', [idUserOrigin, code, emailOrigin, emailTarget, finalLifetime], function(err) {
            if (err) {
                return callback(err);
            }
            Cassandra.runQuery('INSERT INTO "TransferByEmail" ("emailOrigin", "code", "idUserOrigin", "emailTarget") VALUES (?, ?, ?, ?) USING TTL ?', [emailOrigin, code, idUserOrigin, emailTarget, finalLifetime], function(err) {
                if (err) {
                    return callback(err);
                }
                getTransferById(idUserOrigin, function (err, transfer) {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, transfer);
                });
            });
        });
    });
};

/**
 * Start the transfer.
 *
 * @param  {String}         emailOrigin             Email origin
 * @param  {String}         code                    Code generated by a fonction 
 * @param  {String}         emailTarget             Email target
 * @param  {String}         idUserTarget            Id user target
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {managers}       callback.managers       All the managers of user resource
 */
 var makeTransfer = module.exports.makeTransfer = function (ctx, emailOrigin, code, emailTarget, idUserTarget, callback) {
    // Search write transfer
    getTransferByEmail(emailOrigin, code, function(err, transfer) {
        if (err) {
            return callback(err);
        }

        // If is the correct code
        if(transfer.code === code && transfer.emailTarget === emailTarget) {

            // Modify transfer & AuthzRoles & AuthzMembers
            Cassandra.runQuery('SELECT * FROM "AuthzRoles" WHERE "principalId" = ?', [transfer.idUserOrigin], function(err, result) {
                if (err) {
                    return callback(err);
                }
                var authzRoles = _.chain(result).map(_rowToAuthzRoles);

                // If there is no data to transfer, cancel it
                if (!authzRoles._wrapped[0]) {
                    var err = {'code': 400, 'msg': 'There is no data to transfer'};
                    return callback(err);
                }
                authzRoles = authzRoles._wrapped;

                // Create queries to insert and delete authzRoles and authzMembers
                _getQueriesUpdateUserTargerRoles(authzRoles, idUserTarget, transfer.idUserOrigin, function(err, queries, newAuthzRoles) {
                    if(err) {
                        return callback(err);
                    }
                    if(_.isEmpty(queries)) {
                        return callback(null);
                    }

                    // Run queries
                    Cassandra.runBatchQuery(queries, function(err) {
                        if (err) {
                            return callback(err);
                        } 
                        if (!newAuthzRoles) {
                            return callback(null, null);
                        } 

                        else {

                            // Delete the transfer in the table "Transfer"
                            deleteTransfer(emailOrigin, code, transfer.idUserOrigin, function (err) {
                                if(err) {
                                    return callback(err);
                                } else {

                                    // Get id emailOrigin
                                    PrincipalsDAO.getUserIdsByEmails([emailOrigin], function(err, principalIdOrigin) {
                                        if(err) {
                                            return callback(err);
                                        } 

                                        // Found all managers related to this resource and put then into "managers" 
                                        _getManagers(ctx, newAuthzRoles, idUserTarget, principalIdOrigin, function (err, managers) {
                                            if(err) {
                                                return callback(err);
                                            } else {

                                                // Update editors if there is no manager (without the target user)
                                                _updateEditors(idUserTarget, authzRoles, function(err, updatedEditors) {
                                                    if(err) {
                                                        return callback(err);
                                                    }

                                                    // return managers to send emails
                                                    return callback(null, managers, updatedEditors); 
                                                });

                                            }
                                        });
                                    }); 
                                }
                            });
                        }
                    });
                }); 
            });            
        } else {
            var err = {'code': 400, 'msg': 'Code doesn\'t match'};
            return callback(err);
        }
    });
 };

/**
 * Get a transfer data by an id.
 *
 * @param  {String}         id                      The id of the user who created the transfer
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {transfer}       callback.transfer       User's transfer
 */
var getTransferById = module.exports.getTransferById = function (id, callback) {
    if (_.isEmpty(id)) {
        return callback(null, []);
    }
    Cassandra.runQuery('SELECT * FROM "TransferById" WHERE "idUserOrigin" = ?', [id], function(err, result) {
        if (err) {
            return callback(err);
        }
        var transfer = _.chain(result).map(_rowToTransfer);
        if (_.isEmpty(transfer._wrapped[0])) {
            var err = {};
            err.code = "400";
            err.msg = "Transfer not found";
            return callback(err);
        }
        return callback(null, transfer._wrapped[0]);
    });
};

/**
 * Get a transfer data by an email and a code.
 *
 * @param  {String}         email                   Email of user connected
 * @param  {String}         code                    The transfer code
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {transfer}       callback.transfer       User's transfer
 */
var getTransferByEmail = module.exports.getTransferByEmail = function (emailOrigin, code, callback) {
    if (_.isEmpty(code)) {
        return callback(null, []);
    }
    if (_.isEmpty(emailOrigin)) {
        return callback(null, []);
    }
    Cassandra.runQuery('SELECT * FROM "TransferByEmail" WHERE "emailOrigin" = ? AND "code" = ?', [emailOrigin, code], function(err, result) {
        if (err) {
            return callback(err);
        }
        var transfer = _.chain(result).map(_rowToTransfer);
        if (_.isEmpty(transfer._wrapped[0])) {
            var err = {};
            err.code = "400";
            err.msg = "Transfer not found";
            return callback(err);
        }
        return callback(null, transfer._wrapped[0]);
    });
};

/**
 * Delete a transfer data by an email.
 *
 * @param  {String}         emailOrigin             Email of user connected
 * @param  {String}         code                    The transfer code
 * @param  {String}         idUserOrigin            The id of the user who created the transfer
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 */
var deleteTransfer = module.exports.deleteTransfer = function (emailOrigin, code, idUserOrigin, callback) {
    if (_.isEmpty(emailOrigin)) {
        return callback(null);
    }
    Cassandra.runQuery('DELETE FROM "TransferByEmail" WHERE "emailOrigin" = ? AND "code" = ?', [emailOrigin, code], function(err, result) {
        if(err) {
            return callback(err);
        }
        Cassandra.runQuery('DELETE FROM "TransferById" WHERE "idUserOrigin" = ?', [idUserOrigin], function(err, result) {
            if(err) {
                return callback(err);
            } 
            return callback(null);
        });
    });
};


/**
 * PRIVATE FUNCTIONS
 */

/**
 * Update editors : find all editors and 
 * 
 * @param {Array} newAuthzRoles
 * @param {String} idUserTarget
 *
 * @returns queries, newAuthzRoles
 * @api private used to make the transter
 */
var _updateEditors = function(idUserTarget, newAuthzRoles, callback) {

    var listEditors = [];
    var editors = [];
    var isAnyManager = false;

    newAuthzRoles.forEach(function(res, j, arrj) {

        if(res.role === 'manager' && res.resourceId.split(":")[0] === 'c') {

            // Get all member of a resource
            AuthzAPI.getAllAuthzMembers(res.resourceId, function(err, members) {
                isAnyManager = false;
                editors = [];

                // find a manager
                members.forEach(function(member, i, arri) {
                    if(member.role === "manager" && member.id !== idUserTarget) {
                        isAnyManager = true;
                    }
                    if(member.role === "editor") {
                        editors.push(member.id);
                    }

                    // If there is no manager (exclude the userTarget) and if there is editors, update them all  
                    if(arri.length-1 === i) {
                        if(isAnyManager === false && editors.length !== 0) {
                            var editorsToUpdateArray = {}
                            
                            // Update all editors to manager
                            editors.forEach(function(editorId, k, arrk) {
                                editorsToUpdateArray[editorId] = "manager";

                                // If no more editors, return the list of new managers
                                if(arrk.length-1 === k) {
                                    AuthzAPI.updateRoles(res.resourceId, editorsToUpdateArray, function(err, usersToInvalidate) {
                                        if(err) {
                                            return callback(err);
                                        }

                                        // If no more elements / member / editors 
                                        if(arrj.length-1 === j && arrk.length-1 === k && arri.length-1 === i) {
                                            // Return the list of new managers
                                            return callback(null, editors);
                                        }
                                    });
                                }
                            }); 
                        }
                        else {
                            // If no more elements / member 
                            if(arrj.length-1 === j && arri.length-1 === i) {
                                // Return the list of new managers
                                return callback(null, editors);
                            }
                        }
                    }
                });
            });
        }
        else {
            // If no more elements
            if(arrj.length-1 === j) {
                // Return the list of new managers
                return callback(null, editors);
            }
        }
    });
};

/**
 * Get queries 
 * 
 * @param {Array} authzRoles
 * @param {String} idUserTarget
 *
 * @returns queries, newAuthzRoles
 * @api private used to make the transter
 */
var _getQueriesUpdateUserTargerRoles = function(authzRoles, idUserTarget, idUserOrigin, callback) {
    // Create and run the batch set of queries that will delete and re-create all the AuthzRoles & AuthzMember with the new user id
    _.chain(authzRoles).map(function(hash) { 
        _doUpdate(hash, idUserTarget, idUserOrigin, function (res) {
            if(res) {
                return callback( null, [
                    {
                        'query': 'INSERT INTO "AuthzRoles" ("principalId", "resourceId", "role") VALUES (?, ?, ?)',
                        'parameters': [idUserTarget, hash.resourceId, hash.role]
                    },
                    {
                        'query': 'INSERT INTO "AuthzMembers" ("resourceId", "memberId", "role") VALUES (?, ?, ?)',
                        'parameters': [hash.resourceId, idUserTarget, hash.role]
                    },
                    {
                        'query': 'DELETE FROM "AuthzRoles" WHERE "principalId" = ? AND "resourceId" = ?',
                        'parameters': [hash.principalId, hash.resourceId]
                    },
                    {
                        'query': 'DELETE FROM "AuthzMembers" WHERE "memberId" = ? AND "resourceId" = ?',
                        'parameters': [hash.principalId, hash.resourceId]
                    }
                ], [hash]);
            } else {
                var err = {'code': 400, 'msg': 'There is no data to transfer'};
                return callback(err);
            }
        });
    }).flatten().value();  
};

/**
 * Look at the right of target and origin to make a decision about the transfer. 
 * If both have rights on the document and if the target user have better roles on it, we don't gonna change the right
 * 
 * @param {Object} hash
 * @param {String} idUserTarget
 * @param {String} idUserOrigin
 *
 * @returns boolean
 * @api private used to make the transter
 */
var _doUpdate = function(hash, idUserTarget, idUserOrigin, callback) {
    var originRole = 0;
    var targetRole = 0;
    AuthzAPI.hasRole(idUserTarget, hash.resourceId, AuthzConstants.role.MANAGER, function(err, targetHasRoleManager) {
        AuthzAPI.hasRole(idUserTarget, hash.resourceId, AuthzConstants.role.MEMBER, function(err, targetHasRoleMember) {
            AuthzAPI.hasRole(idUserTarget, hash.resourceId, AuthzConstants.role.EDITOR, function(err, targetHasRoleEditor) {
                AuthzAPI.hasRole(idUserTarget, hash.resourceId, AuthzConstants.role.VIEWER, function(err, targetHasRoleViewer) {
                    AuthzAPI.hasRole(idUserOrigin, hash.resourceId, AuthzConstants.role.MANAGER, function(err, originHasRoleManager) {
                        AuthzAPI.hasRole(idUserOrigin, hash.resourceId, AuthzConstants.role.MEMBER, function(err, originHasRoleMember) {
                            AuthzAPI.hasRole(idUserOrigin, hash.resourceId, AuthzConstants.role.EDITOR, function(err, originHasRoleEditor) {
                                AuthzAPI.hasRole(idUserOrigin, hash.resourceId, AuthzConstants.role.VIEWER, function(err, originHasRoleViewer) {
                                    if(targetHasRoleManager) {
                                        targetRole = 1;
                                    } else if(targetHasRoleMember) {
                                        targetRole = 2;
                                    } else if(targetHasRoleEditor) {
                                        targetRole = 3;
                                    } else if(targetHasRoleViewer) {
                                        targetRole = 4;
                                    } else {
                                        targetRole = 5;
                                    }
                                    if(originHasRoleManager) {
                                        originRole = 1;
                                    } else if(originHasRoleMember) {
                                        originRole = 2;
                                    } else if(originHasRoleEditor) {
                                        originRole = 3;
                                    } else if(originHasRoleViewer) {
                                        originRole = 4;
                                    } else {
                                        originRole = 5;
                                    }

                                    if(targetRole <= originRole) {
                                        return callback(false);
                                    } else {
                                        return callback(true);
                                    }
                                });
                            });
                        });
                    });
                }); 
            });
        });
    }); 
};

/**
 * Generate a new 8 caracters code
 * 
 * @returns transferCode
 * @api private
 */
var _createTransferCode = function() {
    // parametters : length, memorable, pattern, prefix
    return CodeGenerator(20, false);
};

/**
 * Get managers from authzroles
 * 
 * @param {Object} ctx
 * @param {Array} authzRoles
 * @param {String} idUserTarget
 * @param {String} principalIdOrigin
 *
 * @returns managers
 * @api private
 */
var _getManagers = function (ctx, authzRoles, idUserTarget, principalIdOrigin, callback) {
    // Promise to get all managers
    var promise = new Promise(function(resolve, reject) {
        var managers = [];
        _.chain(authzRoles).map(function(hash) { 

            // Found all managers related to this resource and put then into "managers"
            AuthzAPI.getAuthzMembers(hash.resourceId, null, null, function(err, members) {
                members.forEach(function(res) {

                    // If the user is the manager and if the user isn't the user target
                    if(res.role === "manager") {

                        // Get the user
                        Cassandra.runQuery('SELECT * FROM "Principals" WHERE "principalId" = ?', [res.id], function (err, manager) {
                            manager = _.chain(manager).map(Cassandra.rowToHash)._wrapped[0];
                            if (err) {
                                return callback(err);
                            } else {

                                // Get the name of the document that the user manage and put the manager and the name document into "managers"
                                _getNameDocument(ctx, hash.resourceId, idUserTarget, principalIdOrigin, function (err, result) {
                                    
                                    // TODO resolve error
                                    manager.resource = result;
                                    managers.push(manager);
                                    
                                    // If all managers found, callback
                                    if (managers.length == authzRoles.length) {
                                        resolve(managers);
                                    } 
                                }); 
                            }
                        });
                    }
                });
            });   
        }); 
    });

    // Return managers
    promise.then(function(managers) {
        return callback(null, managers);
    }).catch(function() {
        return callback(null);
    });
};

/**
 * Get the name of the resource by it's id 
 * take advantage of the differentiation of data type to modify the library
 * 
 * @param {String} idResource
 * @param {String} principalId
 * @param {String} principalIdOrigin
 *
 * @returns resource's name
 * @api private
 */
var _getNameDocument = function (ctx, idResource, principalId, principalIdOrigin, callback) {
    resourceType = idResource.split(":")[0];
    var constantDiscussion = DiscussionsConstants.library.DISCUSSIONS_LIBRARY_INDEX_NAME;
    var constantFolder = FoldersConstants.library.FOLDERS_LIBRARY_INDEX_NAME;
    var constantContent = ContentConstants.library.CONTENT_LIBRARY_INDEX_NAME;

    // If the resource is a Content
    if(resourceType === "c") {     
        ContentDAO.getContent(idResource, function(err, result) {
            if(err) {
                return callback(err);
            }
            // Add to library
            _insertOnLibrary(result, principalId, constantContent, function(err) {
                if(err) {
                    return callback(err, result.displayName);
                }
                // Remove to library 
                _removeOnLibrary(result, principalIdOrigin, constantContent, function(err) {
                    if(err) {
                        return callback(err, result.displayName);
                    }
                    return callback(null, result.displayName);                
                }); 
            });  
        });

    // If the resource is a Folder
    } else if (resourceType === "g") {
        _getFoldersByGroupIds(ctx, idResource, function(err, result) {
            // if err == 1 the resource is a group
            if(err) {
                if(err === 1) {
                    return callback(null, result.displayName);
                }
                return callback(err);
            }
            // Add to library
            _insertOnLibrary(result, principalId, constantFolder, function(err) {
                if(err) {
                    return callback(err, result.displayName);
                }
                // Remove to library
                _removeOnLibrary(result, principalIdOrigin, constantFolder, function(err) {
                    if(err) {
                        return callback(err, result.displayName);
                    }
                    return callback(null, result.displayName);                
                }); 
            }); 
        }); 

    // If the resource is a Discussion
    } else if (resourceType === "d") {
        DiscussionsDAO.getDiscussion(idResource, function(err, result) {
            if(err) {
                return callback(err);
            }
            // Add to Library
            _insertOnLibrary(result, principalId, constantDiscussion, function(err) {
                if(err) {
                    return callback(err, result.displayName);
                } 
                // Remove to library
                _removeOnLibrary(result, principalIdOrigin, constantDiscussion, function(err) {
                    if(err) {
                        return callback(err, result.displayName);
                    }
                    return callback(null, result.displayName);                
                }); 
            });
        });
    }
};

/**
 * Get folder by group id
 * 
 * @param {Object} ctx
 * @param {String} idResource
 *
 * @returns folder
 * @api private
 */
 var _getFoldersByGroupIds = function (ctx, idResource, callback) {
    Cassandra.runQuery('SELECT * FROM "FoldersGroupId" WHERE "groupId" = ?', [idResource], function(err, result) {
        
        // The resource is a groupe if there is no result to this query
        if(_.chain(result).map(Cassandra.rowToHash)._wrapped[0] === undefined) {
            GroupAPI.getGroup(ctx, idResource, function(err, group) {
                if(err) {
                    return callback(err);
                }
                return callback(1, group);
            });
        } else {
            FoldersDAO.getFolder(_.chain(result).map(Cassandra.rowToHash)._wrapped[0].folderId, function(err, folder) {
                if(err) {
                    return callback(err);
                }
                return callback(null, folder);
            });
        }
    });
};

/**
 * Create a transfer model object from its id and the storage hash
 *
 * @param {String} emailOrigin        
 * @param {Object} hash  
 *   
 * @return {Folder}                         
 * @api private
 */
var _storageHashToTransfer = function (emailOrigin, hash) {
    return new TransferByEmail(
        hash.emailOrigin,
        hash.code,
        hash.idUserOrigin,
        hash.emailTarget
    );
}; 

/**
 * Convert a Helenus Row into a Transfer object
 *
 * @param {row}

 * @return {Transfer}               
 * @api private
 */
var _rowToTransfer = function(row) {
    var storageHash = Cassandra.rowToHash(row);
    try {
        storageHash.previews = JSON.parse(storageHash.previews);
    } catch (err) {
        storageHash.previews = {};
    }
    return _storageHashToTransfer(storageHash.emailOrigin, storageHash);
};

/**
 * Create a authzRoles model object from its id and the storage hash
 *
 * @param {String} principalId        
 * @param {Object} hash  
 *   
 * @return {AuthzRoles}                         
 * @api private
 */
var _storageHashToAuthzRoles = function (principalId, hash) {
    var authzRoles = {
        "principalId": hash.principalId,
        "resourceId": hash.resourceId,
        "role": hash.role
    };
    return authzRoles;
};

/**
 * Convert a Helenus Row into a AuthzRoles object
 *
 * @param {row}

 * @return {AuthzRoles}               
 * @api private
 */
var _rowToAuthzRoles = function(row) {
    var storageHash = Cassandra.rowToHash(row);
    try {
        storageHash.previews = JSON.parse(storageHash.previews);
    } catch (err) {
        storageHash.previews = {};
    }
    return _storageHashToAuthzRoles(storageHash.principalId, storageHash);
};

/**
 * Create a authzMembers model object from its id and the storage hash
 *
 * @param {String} resourceId        
 * @param {Object} hash  
 *   
 * @return {AuthzRoles}                         
 * @api private
 */
var _storageHashToAuthzMembers = function (resourceId, hash) {
    var authzMembers = {
        "resourceId": hash.resourceId,
        "memberId": hash.memberId,
        "role": hash.role
    };
    return authzMembers;
};

/**
 * Convert a Helenus Row into a AuthzMembers object
 *
 * @param {row}

 * @return {AuthzMembers}               
 * @api private
 */
var _rowToAuthzMembers = function(row) {
    var storageHash = Cassandra.rowToHash(row);
    try {
        storageHash.previews = JSON.parse(storageHash.previews);
    } catch (err) {
        storageHash.previews = {};
    }
    return _storageHashToAuthzMembers(storageHash.resourceId, storageHash);
};

/**
 * Create a User model object from its id and the storage hash
 *
 * @param {String} resourceId        
 * @param {Object} hash  
 *   
 * @return {AuthzRoles}                         
 * @api private
 */
var _storageHashToUsers = function (hash) {
    var users = {
        "principalId": hash.principalId,
        "email": hash.email,
        "tenantAlias": hash.tenantAlias
    };
    return users;
};

/**
 * Convert a Helenus Row into a User object
 *
 * @param {row}

 * @return {AuthzMembers}               
 * @api private
 */
var _rowToAuthzUsers = function(row) {
    var storageHash = Cassandra.rowToHash(row);
    try {
        storageHash.previews = JSON.parse(storageHash.previews);
    } catch (err) {
        storageHash.previews = {};
    }
    return _storageHashToUsers(storageHash);
};

/**
 * Get the life timetransfer.
 *
 * @param  {Object}         ctx                     Context to determine the life time of a transfer code
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error
 */
var _getLifeTimeTransfer = function (ctx, callback) {
    if (_.isEmpty(ctx)) {
        return callback(null, []);
    }

    var defaultTime = 1;
    var configkey = "oae-transfer/lifetime/value";

    Cassandra.runQuery('SELECT "value" FROM "Config" WHERE "tenantAlias" = ? AND "configKey" = ?', [ctx.tenant().alias, configkey], function(err, result) {
        if (err) {
            return callback(err);
        }

        if (_.isEmpty(result)) {
            return callback(null, defaultTime);
            
        } else {
            conf = _.chain(result).map(Cassandra.rowToHash)._wrapped[0];
            return callback(null, conf.value);
        }
    });
};

/**
 * Insert an element to the library.
 *
 * @param  {Object}         obj                     The element to add       
 * @param  {Object}         principalId             The id of userTarget
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error
 */
var _insertOnLibrary = function(obj, principalId, constant, callback) {
    var entries = [];
    entries.push({
        'id': principalId,
        'rank': obj.lastModified,
        'resource': obj
    });

    LibraryAPI.Index.insert(constant, entries, callback);
};

/**
 * Remove an element to the library.
 *
 * @param  {Object}         obj                     The element to add       
 * @param  {Object}         principalId             The id of userTarget
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error
 */
var _removeOnLibrary = function(obj, principalId, constant, callback) {
    var entries = [];
    entries.push({
        'id': principalId,
        'rank': obj.lastModified,
        'resource': obj
    });

    LibraryAPI.Index.remove(constant, entries, callback);
};
