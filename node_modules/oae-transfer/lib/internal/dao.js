/*!
 * Copyright 2017 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');
var util = require('util');
var Cassandra = require('oae-util/lib/cassandra');
var CodeGenerator = require('password-generator');
var Async = require('async');
var Transfer = require('oae-transfer/lib/model').Transfer;

// API
var LibraryAPI = require('oae-library'); 
var AuthzAPI = require('oae-authz');
var GroupAPI = require('oae-principals/lib/api.group');

// DAO
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var ContentDAO = require('oae-content/lib/internal/dao.content');
var DiscussionsDAO = require('oae-discussions/lib/internal/dao');
var FoldersDAO = require('oae-folders/lib/internal/dao');

// Constant
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var DiscussionsConstants = require('oae-discussions/lib/constants').DiscussionsConstants;
var ContentConstants = require('oae-content/lib/constants').ContentConstants;
var FoldersConstants = require('oae-folders/lib/constants').FoldersConstants;


/** 
 * PUBLIC FUNCTIONS 
 */

/**
 * Create a new transfer.
 *
 * @param  {String}         emailOrigin             Email origin
 * @param  {String}         emailTarget             Email target
 * @param  {String}         idUserOrigin            Id user origin
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {transfer}       callback.transfer       The transfer that was created
 */
var createTransfer = module.exports.createTransfer = function (ctx, emailOrigin, emailTarget, idUserOrigin, callback) {    
    var code = _createTransferCode();
    var finalTimelife = 0;

    _getTimelifeTransfer(ctx, function (err, timelife){
        if (err){
            return callback(err);
        }
        finalTimelife = timelife * 86400;

        Cassandra.runQuery('INSERT INTO "Transfer" ("emailOrigin", "code", "emailTarget", "idUserOrigin") VALUES (?, ?, ?, ?) USING TTL ?', [emailOrigin, code, emailTarget, idUserOrigin, finalTimelife], function(err) {
            if (err) {
                return callback(err);
            }

            getTransferByEmail(emailOrigin, function (err, transfer){
                if (err){
                    return callback(err);
                }
                return callback(null, transfer);
            });
        });
    });
};

/**
 * Start the transfer.
 *
 * @param  {String}         emailOrigin             Email origin
 * @param  {String}         code                    Code generated by a fonction 
 * @param  {String}         emailTarget             Email target
 * @param  {String}         idUserTarget            Id user target
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {managers}       callback.managers       All the managers of user resource
 */
 var makeTransfer = module.exports.makeTransfer = function (ctx, emailOrigin, code, emailTarget, idUserTarget, callback){
    // Search write transfer
    getTransferByEmail(emailOrigin, function(err, transfer) {
        if (err) {
            return callback(err);
        }
        // If is the correct code
        if(transfer.code === code && transfer.emailTarget === emailTarget){
            // Modify transfer & AuthzRoles & AuthzMembers
            Cassandra.runQuery('SELECT * FROM "AuthzRoles" WHERE "principalId" = ?', [transfer.idUserOrigin], function(err, result){
                if (err) {
                    return callback(err);
                }
                var authzRoles = _.chain(result).map(_rowToAuthzRoles);
                // If there is no data to transfer, cancel it
                if (!authzRoles._wrapped[0]){
                    var err = {};
                    err.code = '400';
                    err.msg = 'There is no data to transfer';
                    return callback(err);
                }
                authzRoles = authzRoles._wrapped;
                // Create queries to insert and delete authzRoles and authzMembers
                Async.series({
                    res: function(callback){
                        _getQueries(authzRoles, idUserTarget, transfer.idUserOrigin, function(err, queries, newAuthzRoles){
                            if(err){
                                callback(err);
                            }
                            callback(null, queries, newAuthzRoles);
                        });
                    }
                }, function(err, results){
                    if(err){
                        return callback(err);
                    }
                    // Execute queries and then get managers (to send email to managers later)
                    _executeQueries(results.res[0], emailOrigin, idUserTarget, ctx, results.res[1], function(err, managers){
                        return callback(null, managers);
                    });
                });
            });            
        } else {
            var err = {};
            err.code = '400';
            err.msg = 'Code doesn\'t match';
            return callback(err);
        }
    });
 };

/**
 * Get a transfer data by an email.
 *
 * @param  {String}         email                   Email of user connected
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {transfer}       callback.transfer       User's transfer
 */
var getTransferByEmail = module.exports.getTransferByEmail = function (email, callback) {
    if (_.isEmpty(email)) {
        return callback(null, []);
    }
    Cassandra.runQuery('SELECT * FROM "Transfer" WHERE "emailOrigin" = ?', [email], function(err, result) {
        if (err) {
            return callback(err);
        }
        var transfer = _.chain(result).map(_rowToTransfer);
        if (_.isEmpty(transfer._wrapped[0])) {
            var err = {};
            err.code = "400";
            err.msg = "Transfer not found";
            return callback(err);
        }
        return callback(null, transfer._wrapped[0]);
    });
};

/**
 * Delete a transfer data by an email.
 *
 * @param  {String}         emailOrigin             Email of user connected
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 */
var deleteTransfer = module.exports.deleteTransfer = function (emailOrigin, callback) {
    if (_.isEmpty(emailOrigin)) {
        return callback(null);
    }
    Cassandra.runQuery('DELETE FROM "Transfer" WHERE "emailOrigin" = ?', [emailOrigin], function(err, result) {
        if(err) {
            return callback(err);
        }
    });
    return callback(null);
};


/**
 * PRIVATE FUNCTIONS
 */

/**
 * Get queries 
 * 
 * @param {any} authzRoles
 * @param {any} idUserTarget
 *
 * @returns queries, newAuthzRoles
 * @api private used to make the transter
 */
_getQueries = function(authzRoles, idUserTarget, idUserOrigin, callback){
    Async.series({
        res: function(callback){
            // Create and run the batch set of queries that will delete and re-create all the AuthzRoles & AuthzMember with the new user id
            _.chain(authzRoles).map(function(hash) { 
                _doUpdate(hash, idUserTarget, idUserOrigin, function (res){
                    if(res){
                        callback( null, [
                            {
                                'query': 'INSERT INTO "AuthzRoles" ("principalId", "resourceId", "role") VALUES (?, ?, ?)',
                                'parameters': [idUserTarget, hash.resourceId, hash.role]
                            },
                            {
                                'query': 'INSERT INTO "AuthzMembers" ("resourceId", "memberId", "role") VALUES (?, ?, ?)',
                                'parameters': [hash.resourceId, idUserTarget, hash.role]
                            },
                            {
                                'query': 'DELETE FROM "AuthzRoles" WHERE "principalId" = ? AND "resourceId" = ?',
                                'parameters': [hash.principalId, hash.resourceId]
                            },
                            {
                                'query': 'DELETE FROM "AuthzMembers" WHERE "memberId" = ? AND "resourceId" = ?',
                                'parameters': [hash.principalId, hash.resourceId]
                            }
                        ], [hash]);
                    } else {
                        callback(null, null);
                    }
                });
            }).flatten().value();  
        }
    }, function(err, results){
        if(results.res){
            return callback(null, results.res[0], results.res[1]);
        } else {
            var err = {};
            err.code = "400";
            err.msg = "There is no data to transfer";
            return callback(err);
        }
        
    });
};

/**
 * Look at the right of target and origin to make a decision about the transfer. 
 * If both have rights on the document and if the target user have better roles on it, we don't gonna change the right
 * 
 * @param {any} hash
 * @param {any} idUserTarget
 * @param {any} idUserOrigin
 *
 * @returns boolean
 * @api private used to make the transter
 */
_doUpdate = function(hash, idUserTarget, idUserOrigin, callback){
    var originRole = 0;
    var targetRole = 0;
    AuthzAPI.hasRole(idUserTarget, hash.resourceId, AuthzConstants.role.MANAGER, function(err, targetHasRoleManager) {
        AuthzAPI.hasRole(idUserTarget, hash.resourceId, AuthzConstants.role.MEMBER, function(err, targetHasRoleMember) {
            AuthzAPI.hasRole(idUserTarget, hash.resourceId, AuthzConstants.role.EDITOR, function(err, targetHasRoleEditor) {
                AuthzAPI.hasRole(idUserTarget, hash.resourceId, AuthzConstants.role.VIEWER, function(err, targetHasRoleViewer) {
                    AuthzAPI.hasRole(idUserOrigin, hash.resourceId, AuthzConstants.role.MANAGER, function(err, originHasRoleManager) {
                        AuthzAPI.hasRole(idUserOrigin, hash.resourceId, AuthzConstants.role.MEMBER, function(err, originHasRoleMember) {
                            AuthzAPI.hasRole(idUserOrigin, hash.resourceId, AuthzConstants.role.EDITOR, function(err, originHasRoleEditor) {
                                AuthzAPI.hasRole(idUserOrigin, hash.resourceId, AuthzConstants.role.VIEWER, function(err, originHasRoleViewer) {
                                    if(targetHasRoleManager){
                                        targetRole = 1;
                                    } else if(targetHasRoleMember){
                                        targetRole = 2;
                                    } else if(targetHasRoleEditor){
                                        targetRole = 3;
                                    } else if(targetHasRoleViewer){
                                        targetRole = 4;
                                    } else {
                                        targetRole = 5;
                                    }
                                    if(originHasRoleManager){
                                        originRole = 1;
                                    } else if(originHasRoleMember){
                                        originRole = 2;
                                    } else if(originHasRoleEditor){
                                        originRole = 3;
                                    } else if(originHasRoleViewer){
                                        originRole = 4;
                                    } else {
                                        originRole = 5;
                                    }

                                    if(targetRole <= originRole){
                                        return callback(false);
                                    } else {
                                        return callback(true);
                                    }
                                });
                            });
                        });
                    });
                }); 
            });
        });
    }); 
};

/**
 * Execute queries 
 * 
 * @param {any} queries
 * @param {any} emailOrigin
 * @param {any} ctx
 * @param {any} authzRoles
 *
 * @returns managers
 * @api private used to make the transter
 */
_executeQueries = function(queries, emailOrigin, idUserTarget, ctx, authzRoles, callback){
    // Update AuthzRoles & AuthzMembers
    Cassandra.runBatchQuery(queries, function(err) {
        if (err) {
            return callback(err);
        } 
        if (!authzRoles){
            return callback(null, null);
        } else {
            // Delete the transfer in the table "Transfer"
            deleteTransfer(emailOrigin, function (err){
                if(err){
                    return callback(err);
                } else {
                    // Get id emailOrigin
                    PrincipalsDAO.getUserIdsByEmails(emailOrigin, function(err, principalIdOrigin){
                        if(err){
                            return callback(err);
                        } 
                        // Found all managers related to this resource and put then into "managers" 
                        _getManagers(ctx, authzRoles, idUserTarget, principalIdOrigin, function (err, managers){
                            if(err){
                                return callback(err);
                            } else {
                                // return managers to send emails
                                return callback(null, managers);
                            }
                        });
                    }); 
                }
            });
        }
    });
};

/**
 * Generate a new 8 caracters code
 * 
 * @returns transferCode
 * @api private
 */
var _createTransferCode = function(){
    // parametters : length, memorable, pattern, prefix
    return CodeGenerator(12, false);
};

/**
 * Get managers from authzroles
 * 
 * @param {any} ctx
 * @param {any} authzRoles
 *
 * @returns managers
 * @api private
 */
var _getManagers = function (ctx, authzRoles, idUserTarget, principalIdOrigin, callback){
    // Promise to get all managers
    var promise = new Promise(function(resolve, reject){
        var managers = [];
        _.chain(authzRoles).map(function(hash) { 
            // Found all managers related to this resource and put then into "managers"
            AuthzAPI.getAuthzMembers(hash.resourceId, null, null, function(err, members){
                members.forEach(function(res) {
                    // If the user is the manager and if the user isn't the user target
                    if(res.role === "manager"){
                        // Get the user
                        Cassandra.runQuery('SELECT * FROM "Principals" WHERE "principalId" = ?', [res.id], function (err, manager) {
                            manager = _.chain(manager).map(Cassandra.rowToHash)._wrapped[0];
                            if (err) {
                                return callback(err);
                            } else {
                                // Get the name of the document that the user manage and put the manager and the name document into "managers"
                                _getNameDocument(ctx, hash.resourceId, idUserTarget, principalIdOrigin, function (err, result){
                                    // TODO resolve error
                                    manager.resource = result;
                                    managers.push(manager);
                                    // If all managers found, callback
                                    if (managers.length == authzRoles.length){
                                        resolve(managers);
                                    } 
                                }); 
                            }
                        });
                    }
                });
            });   
        }); 
    });

    // Return managers
    promise.then(function(managers){
        return callback(null, managers);
    }).catch(function(){
        return callback(null);
    });
};

/**
 * Get the name of the resource by it's id 
 * take advantage of the differentiation of data type to modify the library
 * 
 * @param {any} idResource
 *
 * @returns resource's name
 * @api private
 */
var _getNameDocument = function (ctx, idResource, principalId, principalIdOrigin, callback){
    resourceType = idResource.split(":")[0];
    var constantDiscussion = DiscussionsConstants.library.DISCUSSIONS_LIBRARY_INDEX_NAME;
    var constantFolder = FoldersConstants.library.FOLDERS_LIBRARY_INDEX_NAME;
    var constantContent = ContentConstants.library.CONTENT_LIBRARY_INDEX_NAME;

    // If the resource is a Content
    if(resourceType === "c"){     
        ContentDAO.getContent(idResource, function(err, result){
            if(err){
                return callback(err);
            }
            // Add to library
            _insertOnLibrary(result, principalId, constantContent, function(err){
                if(err){
                    return callback(err, result.displayName);
                }
                // Remove to library 
                _removeOnLibrary(result, principalIdOrigin, constantContent, function(err){
                    if(err){
                        return callback(err, result.displayName);
                    }
                    return callback(null, result.displayName);                
                }); 
            });  
        });

    // If the resource is a Folder
    } else if (resourceType === "g"){
        _getFoldersByGroupIds(ctx, idResource, function(err, result){
            // if err == 1 the resource is a group
            if(err){
                if(err === 1){
                    return callback(null, result.displayName);
                }
                return callback(err);
            }
            // Add to library
            _insertOnLibrary(result, principalId, constantFolder, function(err){
                if(err){
                    return callback(err, result.displayName);
                }
                // Remove to library
                _removeOnLibrary(result, principalIdOrigin, constantFolder, function(err){
                    if(err){
                        return callback(err, result.displayName);
                    }
                    return callback(null, result.displayName);                
                }); 
            }); 
        }); 

    // If the resource is a Discussion
    } else if (resourceType === "d"){
        DiscussionsDAO.getDiscussion(idResource, function(err, result){
            if(err){
                return callback(err);
            }
            // Add to Library
            _insertOnLibrary(result, principalId, constantDiscussion, function(err){
                if(err){
                    return callback(err, result.displayName);
                } 
                // Remove to library
                _removeOnLibrary(result, principalIdOrigin, constantDiscussion, function(err){
                    if(err){
                        return callback(err, result.displayName);
                    }
                    return callback(null, result.displayName);                
                }); 
            });
        });
    }
};

/**
 * Get folder by group id
 * 
 * @param {any} idResource
 *
 * @returns folder
 * @api private
 */
 // the 
 var _getFoldersByGroupIds = function (ctx, idResource, callback){
    Cassandra.runQuery('SELECT * FROM "FoldersGroupId" WHERE "groupId" = ?', [idResource], function(err, result){
        // The resource is a groupe if there is no result to this query
        if(_.chain(result).map(Cassandra.rowToHash)._wrapped[0] === undefined){
            GroupAPI.getGroup(ctx, idResource, function(err, group){
                if(err){
                    return callback(err);
                }
                return callback(1, group);
            });
        } else {
            FoldersDAO.getFolder(_.chain(result).map(Cassandra.rowToHash)._wrapped[0].folderId, function(err, folder){
                if(err){
                    return callback(err);
                }
                return callback(null, folder);
            });
        }
    });
};

/**
 * Create a transfer model object from its id and the storage hash
 *
 * @param {String} emailOrigin        
 * @param {Object} hash  
 *   
 * @return {Folder}                         
 * @api private
 */
var _storageHashToTransfer = function (emailOrigin, hash) {
    return new Transfer(
        hash.emailOrigin,
        hash.code,
        hash.emailTarget,
        hash.idUserOrigin
    );
};

/**
 * Convert a Helenus Row into a Transfer object
 *
 * @param {row}

 * @return {Transfer}               
 * @api private
 */
var _rowToTransfer = function(row) {
    var storageHash = Cassandra.rowToHash(row);
    try {
        storageHash.previews = JSON.parse(storageHash.previews);
    } catch (err) {
        storageHash.previews = {};
    }
    return _storageHashToTransfer(storageHash.emailOrigin, storageHash);
};

/**
 * Create a authzRoles model object from its id and the storage hash
 *
 * @param {String} principalId        
 * @param {Object} hash  
 *   
 * @return {AuthzRoles}                         
 * @api private
 */
var _storageHashToAuthzRoles = function (principalId, hash) {
    var authzRoles = {
        "principalId": hash.principalId,
        "resourceId": hash.resourceId,
        "role": hash.role
    };
    return authzRoles;
};

/**
 * Convert a Helenus Row into a AuthzRoles object
 *
 * @param {row}

 * @return {AuthzRoles}               
 * @api private
 */
var _rowToAuthzRoles = function(row) {
    var storageHash = Cassandra.rowToHash(row);
    try {
        storageHash.previews = JSON.parse(storageHash.previews);
    } catch (err) {
        storageHash.previews = {};
    }
    return _storageHashToAuthzRoles(storageHash.principalId, storageHash);
};

/**
 * Create a authzMembers model object from its id and the storage hash
 *
 * @param {String} resourceId        
 * @param {Object} hash  
 *   
 * @return {AuthzRoles}                         
 * @api private
 */
var _storageHashToAuthzMembers = function (resourceId, hash) {
    var authzMembers = {
        "resourceId": hash.resourceId,
        "memberId": hash.memberId,
        "role": hash.role
    };
    return authzMembers;
};

/**
 * Convert a Helenus Row into a AuthzMembers object
 *
 * @param {row}

 * @return {AuthzMembers}               
 * @api private
 */
var _rowToAuthzMembers = function(row) {
    var storageHash = Cassandra.rowToHash(row);
    try {
        storageHash.previews = JSON.parse(storageHash.previews);
    } catch (err) {
        storageHash.previews = {};
    }
    return _storageHashToAuthzMembers(storageHash.resourceId, storageHash);
};

/**
 * Create a User model object from its id and the storage hash
 *
 * @param {String} resourceId        
 * @param {Object} hash  
 *   
 * @return {AuthzRoles}                         
 * @api private
 */
var _storageHashToUsers = function (hash) {
    var users = {
        "principalId": hash.principalId,
        "email": hash.email,
        "tenantAlias": hash.tenantAlias
    };
    return users;
};

/**
 * Convert a Helenus Row into a User object
 *
 * @param {row}

 * @return {AuthzMembers}               
 * @api private
 */
var _rowToAuthzUsers = function(row) {
    var storageHash = Cassandra.rowToHash(row);
    try {
        storageHash.previews = JSON.parse(storageHash.previews);
    } catch (err) {
        storageHash.previews = {};
    }
    return _storageHashToUsers(storageHash);
};

/**
 * Get the time life transfer.
 *
 * @param  {Object}         ctx                     Context to determine the time life of a transfer code
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error
 */
// TODO 
var _getTimelifeTransfer = function (ctx, callback) {
    if (_.isEmpty(ctx)) {
        return callback(null, []);
    }

    var defaultTime = 1;
    var configkey = "oae-transfer/timelifeTransfer/timelife";

    Cassandra.runQuery('SELECT "value" FROM "Config" WHERE "tenantAlias" = ? AND "configKey" = ?', [ctx.tenant().alias, configkey], function(err, result) {
        if (err) {
            return callback(err);
        }

        if (_.isEmpty(result)){
            return callback(null, defaultTime);
            
        } else {
            conf = _.chain(result).map(Cassandra.rowToHash)._wrapped[0];
            return callback(null, conf.value);
        }
    });
};

/**
 * Insert an element to the library.
 *
 * @param  {Object}         obj                     The element to add       
 * @param  {Object}         principalId             The id of userTarget
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error
 */
// TODO
var _insertOnLibrary = function(obj, principalId, constant, callback){
    var entries = [];
    entries.push({
        'id': principalId,
        'rank': obj.lastModified,
        'resource': obj
    });

    LibraryAPI.Index.insert(constant, entries, callback);
};

/**
 * Remove an element to the library.
 *
 * @param  {Object}         obj                     The element to add       
 * @param  {Object}         principalId             The id of userTarget
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error
 */
// TODO
var _removeOnLibrary = function(obj, principalId, constant, callback){
    var entries = [];
    entries.push({
        'id': principalId,
        'rank': obj.lastModified,
        'resource': obj
    });

    LibraryAPI.Index.remove(constant, entries, callback);
};
