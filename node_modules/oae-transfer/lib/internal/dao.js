/*!
 * Copyright 2017 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');
var util = require('util');
var Cassandra = require('oae-util/lib/cassandra');
var CodeGenerator = require('password-generator');
var Async = require('async');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var ContentConstants = require('oae-content/lib/constants').ContentConstants;
var ContentDAO = require('oae-content/lib/internal/dao.content');
var DiscussionsConstants = require('oae-discussions/lib/constants').DiscussionsConstants;
var DiscussionsDAO = require('oae-discussions/lib/internal/dao');
var FoldersConstants = require('oae-folders/lib/constants').FoldersConstants;
var FoldersDAO = require('oae-folders/lib/internal/dao');
var GroupAPI = require('oae-principals/lib/api.group');
var LibraryAPI = require('oae-library'); 
var MeetingsAPI = require('oae-jitsi/lib/api.meetings'); // TODO : remove lib/api.meetings
var MeetingsConstants = require('oae-jitsi/lib/constants').MeetingsConstants;
var MeetingsDAO = require('oae-jitsi/lib/internal/dao');
var PrincipalsAPI = require('oae-principals/lib/api.user');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');

var TransferByEmail = require('oae-transfer/lib/model').TransferByEmail;


/** 
 * PUBLIC FUNCTIONS 
 */

/**
 * Create a new transfer and return it
 *
 * @param  {Object}         ctx                     Context
 * @param  {String}         idUserOrigin            Id user origin
 * @param  {String}         emailOrigin             Email origin
 * @param  {String}         emailTarget             Email target
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {transfer}       callback.transfer       The transfer that was created
 */
var createTransfer = module.exports.createTransfer = function (ctx, idUserOrigin, emailOrigin, emailTarget, callback) {    
    var code = _createTransferCode();
    var finalLifetime = 0;

    // Initialize life time of the transfer
    _getLifeTimeTransfer(ctx, function (err, lifetime) {
        if (err) {
            return callback(err);
        }
        finalLifetime = lifetime * 86400;

        // Create transfer
        Cassandra.runQuery('INSERT INTO "TransferById" ("idUserOrigin", "code", "emailOrigin", "emailTarget") VALUES (?, ?, ?, ?) USING TTL ?', [idUserOrigin, code, emailOrigin, emailTarget, finalLifetime], function(err) {
            if (err) {
                return callback(err);
            }
            Cassandra.runQuery('INSERT INTO "TransferByEmail" ("emailOrigin", "code", "idUserOrigin", "emailTarget") VALUES (?, ?, ?, ?) USING TTL ?', [emailOrigin, code, idUserOrigin, emailTarget, finalLifetime], function(err) {
                if (err) {
                    return callback(err);
                }

                // Return transfer
                getTransferById(idUserOrigin, function (err, transfer) {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, transfer);
                });
            });
        });
    });
};

/**
 * Start the transfer.
 *
 * @param  {String}         emailOrigin                 Email origin
 * @param  {String}         code                        Code generated by a fonction 
 * @param  {String}         emailTarget                 Email target
 * @param  {String}         idUserTarget                Id user target
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error that occurred, if any
 * @param  {managers}       callback.managers           All the managers of user resource
 * @param  {editors}        callback.updatedEditors     All the updated editors of user resource
 */
 var makeTransfer = module.exports.makeTransfer = function (ctx, emailOrigin, code, emailTarget, idUserTarget, callback) {

    // Find transfer
    getTransferByEmail(emailOrigin, code, function(err, transfer) {
        if (err) {
            return callback(err);
        }

        // If is the correct code
        if(transfer.code === code && transfer.emailTarget === emailTarget) {

            // Modify transfer & AuthzRoles & AuthzMembers
            Cassandra.runQuery('SELECT * FROM "AuthzRoles" WHERE "principalId" = ?', [transfer.idUserOrigin], function(err, result) {
                if (err) {
                    return callback(err);
                }
                var authzRoles = _.chain(result).map()._wrapped;

                // If there is no data to transfer, cancel it
                if (_.isEmpty(authzRoles)) {
                    err = {'code': 400, 'msg': 'There is no data to transfer'};
                    return callback(err);
                }

                // Create queries to insert and delete authzRoles and authzMembers
                _getQueriesUpdateUserRoles(authzRoles, idUserTarget, transfer.idUserOrigin, function(err, newAuthzRoles) {
                    if(err) {
                        return callback(err);
                    }
                    if (_.isEmpty(newAuthzRoles)) {
                        var err = {'code': 400, 'msg': 'There is no data to transfer'};
                        return callback(err);
                    } 

                    // Delete the transfer in the table "Transfer"
                    deleteTransfer(emailOrigin, code, transfer.idUserOrigin, function (err) {
                        if(err) {
                            return callback(err);
                        } else {

                            // Get id emailOrigin
                            PrincipalsDAO.getUserIdsByEmails([emailOrigin], function(err, principalIdOrigin) {
                                if(err) {
                                    return callback(err);
                                } 

                                // Found all managers related to this resource and put then into "managers" 
                                _getManagers(ctx, newAuthzRoles, idUserTarget, principalIdOrigin, function (err, managers) {
                                    if(err) {
                                        return callback(err);
                                    } 

                                    // Update editors if there is no manager (without the target user)
                                    _updateEditors(ctx, idUserTarget, newAuthzRoles, function(err, updatedEditors) {
                                        if(err) {
                                            return callback(err);
                                        }
                                        // return managers to send emails
                                        return callback(null, managers, updatedEditors); 
                                    });
                                });
                            }); 
                        }
                    });
                }); 
            });            
        } else {
            var err = {'code': 400, 'msg': 'Code doesn\'t match'};
            return callback(err);
        }
    });
 };

/**
 * Get a transfer data by an id.
 *
 * @param  {String}         id                      The id of the user who created the transfer
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {transfer}       callback.transfer       User's transfer
 */
var getTransferById = module.exports.getTransferById = function (id, callback) {
    if (_.isEmpty(id)) {
        return callback(null, []);
    }

    Cassandra.runQuery('SELECT * FROM "TransferById" WHERE "idUserOrigin" = ?', [id], function(err, result) {
        if (err) {
            return callback(err);
        }

        var transfer = _.chain(result).map();
        transfer = transfer._wrapped[0];

        if (_.isEmpty(transfer)) {
            var err = {'code': 400, 'msg': 'Transfer not found'};
            return callback(err);
        }
        return callback(null, transfer);
    });
};

/**
 * Get a transfer data by an email and a code.
 *
 * @param  {String}         email                   Email of user connected
 * @param  {String}         code                    The transfer code
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {transfer}       callback.transfer       User's transfer
 */
var getTransferByEmail = module.exports.getTransferByEmail = function (emailOrigin, code, callback) {
    if (_.isEmpty(code)) {
        return callback(null, []);
    }
    if (_.isEmpty(emailOrigin)) {
        return callback(null, []);
    }

    Cassandra.runQuery('SELECT * FROM "TransferByEmail" WHERE "emailOrigin" = ? AND "code" = ?', [emailOrigin, code], function(err, result) {
        if (err) {
            return callback(err);
        }

        var transfer = _.chain(result).map()._wrapped[0];

        if (_.isEmpty(transfer)) {
            var err = {'code': 400, 'msg': 'Transfer not found'};
            return callback(err);
        }
        return callback(null, transfer);
    });
};

/**
 * Delete a transfer data by an email.
 *
 * @param  {String}         code                    The transfer code
 * @param  {String}         emailOrigin             Email of user connected
 * @param  {String}         idUserOrigin            The id of the user who created the transfer
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 */
var deleteTransfer = module.exports.deleteTransfer = function (emailOrigin, code, idUserOrigin, callback) {
    if (_.isEmpty(emailOrigin)) {
        return callback(null);
    }
    Cassandra.runQuery('DELETE FROM "TransferByEmail" WHERE "emailOrigin" = ? AND "code" = ?', [emailOrigin, code], function(err, result) {
        if(err) {
            return callback(err);
        }
        Cassandra.runQuery('DELETE FROM "TransferById" WHERE "idUserOrigin" = ?', [idUserOrigin], function(err, result) {
            if(err) {
                return callback(err);
            } 
            return callback(null);
        });
    });
};


/**
 * PRIVATE FUNCTIONS
 */

/**
 * Update editors to manager if there is only one manager on a resource and if the manager is the user who's tranferring his datas
 * 
 * @param {Object}  ctx
 * @param {String}  idUserTarget
 * @param {Array}   newAuthzRoles
 *
 * @returns array of roles modified
 * @api private used to make the transter
 */
var _updateEditors = function(ctx, idUserTarget, newAuthzRoles, callback) {
    if(_.isEmpty(newAuthzRoles)) {
        return callback(null, null);
    }

    // Liste of ids editors && role for one resource
    var editorsToUpdateArray = [];
    // List of ids editors
    var editors = [];
    // True of there is another manager different of the userTarget
    var isAnyManager = false;

    newAuthzRoles.forEach(function(res, j, arrj) {

        if(res.role === 'manager' && res.resourceId.split(":")[0] === 'c') {

            // Get all member of a resource
            AuthzAPI.getAllAuthzMembers(res.resourceId, function(err, members) {
                if(_.isEmpty(members)) {
                    return callback(null, null);
                }
                isAnyManager = false;
                editors = [];

                // find a manager
                members.forEach(function(member, i, arri) {
                    if(member.role === "manager" && member.id !== idUserTarget) {
                        isAnyManager = true;
                    }
                    if(member.role === "editor") {
                        editors.push(member.id);
                    }

                    // If there is no manager (exclude the userTarget) and if there is editors, update them all  
                    if(arri.length-1 === i) {
                        if(isAnyManager === false && editors.length !== 0) {
                            var editorsToUpdateRole = {};

                            // Update all editors to manager
                            editors.forEach(function(editorId, k, arrk) {
                                editorsToUpdateRole[editorId] = "manager";

                                PrincipalsDAO.getPrincipal(editorId, function(err, principal) {
                                    if(err) {
                                        return callback(err);
                                    }

                                    // Get the name of the document
                                    _getDocument(ctx, res.resourceId, function (err, element) {
                                        editorsToUpdateArray.push(principal);

                                        // If no more editors, return the list of new managers
                                        if(arrk.length-1 === k) {
                                            AuthzAPI.updateRoles(element.id, editorsToUpdateRole, function(err, usersToInvalidate) {
                                                if(err) {
                                                    return callback(err);
                                                }

                                                // If no more elements / member / editors 
                                                if(arrj.length-1 === j && arrk.length-1 === k && arri.length-1 === i) {
                                                    // Return the list of new managers
                                                    return callback(null, editorsToUpdateArray);
                                                }
                                            });
                                        }
                                    }); 
                                }); 
                            }); 
                        }
                        else {
                            // If no more elements / member 
                            if(arrj.length-1 === j && arri.length-1 === i) {
                                // Return the list of new managers
                                return callback(null, editorsToUpdateArray);
                            }
                        }
                    }
                });
            });
        }
        else {
            // If no more elements
            if(arrj.length-1 === j) {
                // Return the list of new managers
                return callback(null, editorsToUpdateArray);
            }
        }
    });
};

/**
 * Update roles and Get array of roles modified
 * 
 * @param {Array}       authzRoles
 * @param {String}      idUserTarget
 * @param {String}      idUserOrigin
 * @param {Function}    callback                
 * @param {Array}       _userHashes
 *
 * @returns array of roles modified
 * @api private used to make the transter
 */
var _getQueriesUpdateUserRoles = function(authzRoles, idUserTarget, idUserOrigin, callback, _userHashes) {

    _userHashes = _userHashes || []
    
    // If no more authzroles, return list of modified roles
    if (_.isEmpty(authzRoles)) {
        return callback(null, _userHashes);
    }

    var authzRole = authzRoles.shift();
    var memberToUpdate = {};
    var memberToRemove = {};
    var newAuthzRoles = {};

    _doUpdate(authzRole, idUserTarget, idUserOrigin, function (res) {

        if(res) {

            memberToUpdate[idUserTarget] = authzRole.role;

            // Update target user's role
            AuthzAPI.updateRoles(authzRole.resourceId, memberToUpdate, function(err, usersToInvalidate) {
                if(err) {
                    return callback(err);
                }

                memberToRemove[idUserOrigin] = false;

                // Remove origin user's role
                AuthzAPI.updateRoles(authzRole.resourceId, memberToRemove, function(err, usersToInvalidate) {
                    if(err) {
                        return callback(err);
                    }

                    newAuthzRoles["resourceId"] = authzRole.resourceId;
                    newAuthzRoles["role"] = authzRole.role;
                    newAuthzRoles["principalId"] = idUserTarget;
                    _userHashes.push(newAuthzRoles);

                    return _getQueriesUpdateUserRoles(authzRoles, idUserTarget, idUserOrigin, callback, _userHashes);
                });
            });
        } else {
            return _getQueriesUpdateUserRoles(authzRoles, idUserTarget, idUserOrigin, callback, _userHashes);
        }
    });
};

/**
 * Look at the right of target and origin to make a decision about the transfer. 
 * If both have rights on the document and if the target user have better roles on it, we don't gonna change the right
 * 
 * @param {Object} hash
 * @param {String} idUserTarget
 * @param {String} idUserOrigin
 *
 * @returns boolean
 * @api private used to make the transter
 */
var _doUpdate = function(hash, idUserTarget, idUserOrigin, callback) {
    var originRole = 0;
    var targetRole = 0;
    AuthzAPI.hasRole(idUserTarget, hash.resourceId, AuthzConstants.role.MANAGER, function(err, targetHasRoleManager) {
        AuthzAPI.hasRole(idUserTarget, hash.resourceId, AuthzConstants.role.MEMBER, function(err, targetHasRoleMember) {
            AuthzAPI.hasRole(idUserTarget, hash.resourceId, AuthzConstants.role.EDITOR, function(err, targetHasRoleEditor) {
                AuthzAPI.hasRole(idUserTarget, hash.resourceId, AuthzConstants.role.VIEWER, function(err, targetHasRoleViewer) {
                    AuthzAPI.hasRole(idUserOrigin, hash.resourceId, AuthzConstants.role.MANAGER, function(err, originHasRoleManager) {
                        AuthzAPI.hasRole(idUserOrigin, hash.resourceId, AuthzConstants.role.MEMBER, function(err, originHasRoleMember) {
                            AuthzAPI.hasRole(idUserOrigin, hash.resourceId, AuthzConstants.role.EDITOR, function(err, originHasRoleEditor) {
                                AuthzAPI.hasRole(idUserOrigin, hash.resourceId, AuthzConstants.role.VIEWER, function(err, originHasRoleViewer) {
                                    if(targetHasRoleManager) {
                                        targetRole = 1;
                                    } else if(targetHasRoleMember) {
                                        targetRole = 2;
                                    } else if(targetHasRoleEditor) {
                                        targetRole = 3;
                                    } else if(targetHasRoleViewer) {
                                        targetRole = 4;
                                    } else {
                                        targetRole = 5;
                                    }
                                    if(originHasRoleManager) {
                                        originRole = 1;
                                    } else if(originHasRoleMember) {
                                        originRole = 2;
                                    } else if(originHasRoleEditor) {
                                        originRole = 3;
                                    } else if(originHasRoleViewer) {
                                        originRole = 4;
                                    } else {
                                        originRole = 5;
                                    }

                                    if(targetRole <= originRole) {
                                        return callback(false);
                                    } else {
                                        return callback(true);
                                    }
                                });
                            });
                        });
                    });
                }); 
            });
        });
    }); 
};

/**
 * Generate a new 8 caracters code
 * 
 * @returns transferCode
 * @api private
 */
var _createTransferCode = function() {
    // parametters : length, memorable, pattern, prefix
    return CodeGenerator(20, false);
};

/**
 * Get managers from authzroles
 * 
 * @param {Object}  ctx
 * @param {Array}   authzRoles
 * @param {String}  idUserTarget
 * @param {String}  principalIdOrigin
 *
 * @returns managers
 * @api private
 */
var _getManagers = function (ctx, authzRoles, idUserTarget, principalIdOrigin, callback) {
    if(_.isEmpty(authzRoles)) {
        return callback(null);
    }

    // Promise to get all managers
    var promise = new Promise(function(resolve, reject) {
        var managers = [];
        _.chain(authzRoles).map(function(hash) { 

            // Found all managers related to this resource and put then into "managers"
            AuthzAPI.getAuthzMembers(hash.resourceId, null, null, function(err, members) {
                if(err) {
                    return callback(err);
                }

                members.forEach(function(res, i, arrI) {

                    // If the user is the manager and if the user isn't the user target
                    if(res.role === "manager") {

                        // Get the user
                        Cassandra.runQuery('SELECT * FROM "Principals" WHERE "principalId" = ?', [res.id], function (err, manager) {
                            if(err) {
                                return callback(err);
                            } 

                            // Get resource
                            _getDocument(ctx, hash.resourceId, function (err, element) {
                                if(err) {
                                    return callback(err);
                                }

                                // Insert to library
                                _insertIntoLibrary(ctx, element, idUserTarget, principalIdOrigin, function (err, result) {
                                    if(err) {
                                        return callback(err);
                                    }
                                    
                                    manager = _.chain(manager).map(Cassandra.rowToHash)._wrapped[0];
                                    manager.resource = element;
                                    managers.push(manager);
                                    
                                    // If all managers found, callback
                                    if (arrI.length-1 === i) {
                                        resolve(managers);
                                    } 
                                }); 
                            }); 
                        });
                    } else {
                        if (arrI.length-1 === i) {
                            resolve(managers);
                        } 
                    }
                });
            });   
        }); 
    });

    // Return managers
    promise.then(function(managers) {
        return callback(null, managers);
    }).catch(function() {
        return callback(null);
    });
};

/**
 * Get the name of the resource by it's id 
 * take advantage of the differentiation of data type to modify the library
 * 
 * @param {Object} ctx
 * @param {String} idResource
 * @param {String} principalId
 * @param {String} principalIdOrigin
 *
 * @returns nothing
 * @api private
 */
var _insertIntoLibrary = function (ctx, resource, principalId, principalIdOrigin, callback) {
    var resourceType = resource.id.split(":")[0];
    
    var constant = "";
    var constantDiscussion = DiscussionsConstants.library.DISCUSSIONS_LIBRARY_INDEX_NAME;
    var constantFolder = FoldersConstants.library.FOLDERS_LIBRARY_INDEX_NAME;
    var constantContent = ContentConstants.library.CONTENT_LIBRARY_INDEX_NAME;
    var constantMeeting = ContentConstants.library.MEETINGS_LIBRARY_INDEX_NAME;

    // If the resource is a Content
    if(resourceType === "c") {     
        constant = constantContent;
    // If the resource is a Folder
    } else if (resourceType === "g") {
        constant = constantFolder;
    // If the resource is a Discussion
    } else if (resourceType === "d") {
        constant = constantDiscussion;
    // If the resource is a Discussion
    } else if (resourceType === "m") {
        constant = constantMeeting;
    }

    // Insert to library 
    _insertOnLibrary(resource, principalId, constant, function(err) {
        if(err) {
            return callback(err);
        }

        // Remove to library 
        _removeFromLibrary(resource, principalIdOrigin, constant, function(err) {
            if(err) {
                return callback(err);
            }
            return callback(null);                
        }); 
    }); 
};

/**
 * Get the name of the resource by it's id 
 * take advantage of the differentiation of data type to modify the library
 * 
 * @param {Object} ctx
 * @param {String} idResource
 *
 * @returns resource
 * @api private
 */
var _getDocument = function (ctx, idResource, callback) {
    var resourceType = idResource.split(":")[0];
    // If the resource is a Content
    if(resourceType === "c") {     
        ContentDAO.getContent(idResource, function(err, result) {
            if(err) {
                return callback(err);
            }
            return callback(null, result);        
        });

    // If the resource is a Folder
    } else if (resourceType === "g") {
        _getFoldersByGroupIds(ctx, idResource, function(err, result) {
            // if err == 1 the resource is a group
            if(err) {
                if(err === 1) {
                    return callback(null, result);
                }
                return callback(err);
            }
            return callback(null, result);                
        }); 

    // If the resource is a Discussion
    } else if (resourceType === "d") {
        DiscussionsDAO.getDiscussion(idResource, function(err, result) {
            if(err) {
                return callback(err);
            }
            return callback(null, result);                
        }); 

    // If the resource is a Meeting
    } else if (resourceType === "m") {
        MeetingsDAO.getMeeting(idResource, function(err, result) {
            if(err) {
                return callback(err);
            }
            return callback(null, result);                
        }); 
    }
};

/**
 * Get folder by group id
 * 
 * @param {Object} ctx
 * @param {String} idResource
 *
 * @returns folder
 * @api private
 */
 var _getFoldersByGroupIds = function (ctx, idResource, callback) {
    Cassandra.runQuery('SELECT * FROM "FoldersGroupId" WHERE "groupId" = ?', [idResource], function(err, result) {
        
        // The resource is a groupe if there is no result to this query
        if(_.chain(result).map(Cassandra.rowToHash)._wrapped[0] === undefined) {
            GroupAPI.getGroup(ctx, idResource, function(err, group) {
                if(err) {
                    return callback(err);
                }
                return callback(1, group);
            });
        } else {
            FoldersDAO.getFolder(_.chain(result).map(Cassandra.rowToHash)._wrapped[0].folderId, function(err, folder) {
                if(err) {
                    return callback(err);
                }
                return callback(null, folder);
            });
        }
    });
};

/**
 * Get the life timetransfer.
 *
 * @param  {Object}         ctx                     Context to determine the life time of a transfer code
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error
 */
var _getLifeTimeTransfer = function (ctx, callback) {
    if (_.isEmpty(ctx)) {
        return callback(null, []);
    }

    var defaultTime = 1;
    var configkey = "oae-transfer/lifetime/value";

    Cassandra.runQuery('SELECT "value" FROM "Config" WHERE "tenantAlias" = ? AND "configKey" = ?', [ctx.tenant().alias, configkey], function(err, result) {
        if (err) {
            return callback(err);
        }

        if (_.isEmpty(result)) {
            return callback(null, defaultTime);
            
        } else {
            conf = _.chain(result).map(Cassandra.rowToHash)._wrapped[0];
            return callback(null, conf.value);
        }
    });
};

/**
 * Insert an element to the library.
 *
 * @param  {Object}         obj                     The element to add       
 * @param  {Object}         principalId             The id of userTarget
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error
 */
var _insertOnLibrary = function(obj, principalId, constant, callback) {
    var entries = [];
    entries.push({
        'id': principalId,
        'rank': obj.lastModified,
        'resource': obj
    });

    LibraryAPI.Index.insert(constant, entries, callback);
};

/**
 * Remove an element to the library.
 *
 * @param  {Object}         obj                     The element to add       
 * @param  {Object}         principalId             The id of userTarget
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error
 */
var _removeFromLibrary = function(obj, principalId, constant, callback) {
    var entries = [];
    entries.push({
        'id': principalId,
        'rank': obj.lastModified,
        'resource': obj
    });

    LibraryAPI.Index.remove(constant, entries, callback);
};
